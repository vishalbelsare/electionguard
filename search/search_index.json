{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ElectionGuard is an open source software development kit (SDK) that makes voting more secure, transparent and accessible. Announced on at the Build developer conference , ElectionGuard enables end-to-end verification of elections as well as support the publication of results from ballot comparison audits. The ElectionGuard SDK leverages homomorphic encryption to ensure that votes recorded by electronic systems of any type remain encrypted, secure, and secret. Results can be published online or made available to third-party organizations for secure validation, and allow individual voters to confirm their votes were correctly counted. Important First time to ElectionGuard? Get started in our guide . Open-Source This library and all linked ElectionGuard projects, are licensed under the MIT license. There is no fee for using ElectionGuard. Security Issues Reporting We encourage the developer and security community to conduct research, report issues, and suggest improvements on this code base. However, unlike performance or feature bugs, please do not report security vulnerabilities in public Github comments. Each repository has a SECURITY file with instructions on responsibly reporting security vulnerabilities under Microsoft's CVD process. Contributing Help defend democracy and contribute to the project . We welcome discussions on our discussions page , feel free to check in and ask your questions and drop your suggestions regarding the specifications over there. Questions ElectionGuard would love for you to ask questions out in the open using Github Issues. If you really want to email the ElectionGuard team, reach out at electionguard@microsoft.com . Thanks A huge thank you to those who helped to contribute to this project so far, including: Josh Benaloh (whose PhD thesis was the genesis of much of this work) InfernoRed Technology VotingWorks Center for Civic Design Oxide Design Many teams within Microsoft","title":"Overview"},{"location":"#_1","text":"ElectionGuard is an open source software development kit (SDK) that makes voting more secure, transparent and accessible. Announced on at the Build developer conference , ElectionGuard enables end-to-end verification of elections as well as support the publication of results from ballot comparison audits. The ElectionGuard SDK leverages homomorphic encryption to ensure that votes recorded by electronic systems of any type remain encrypted, secure, and secret. Results can be published online or made available to third-party organizations for secure validation, and allow individual voters to confirm their votes were correctly counted. Important First time to ElectionGuard? Get started in our guide .","title":""},{"location":"#open-source","text":"This library and all linked ElectionGuard projects, are licensed under the MIT license. There is no fee for using ElectionGuard.","title":"Open-Source"},{"location":"#security-issues-reporting","text":"We encourage the developer and security community to conduct research, report issues, and suggest improvements on this code base. However, unlike performance or feature bugs, please do not report security vulnerabilities in public Github comments. Each repository has a SECURITY file with instructions on responsibly reporting security vulnerabilities under Microsoft's CVD process.","title":"Security Issues Reporting"},{"location":"#contributing","text":"Help defend democracy and contribute to the project . We welcome discussions on our discussions page , feel free to check in and ask your questions and drop your suggestions regarding the specifications over there.","title":"Contributing"},{"location":"#questions","text":"ElectionGuard would love for you to ask questions out in the open using Github Issues. If you really want to email the ElectionGuard team, reach out at electionguard@microsoft.com .","title":"Questions"},{"location":"#thanks","text":"A huge thank you to those who helped to contribute to this project so far, including: Josh Benaloh (whose PhD thesis was the genesis of much of this work) InfernoRed Technology VotingWorks Center for Civic Design Oxide Design Many teams within Microsoft","title":"Thanks"},{"location":"Roadmap/","text":"ElectionGuard Roadmap 2021 Roadmap Our 2021 roadmap takes the learnings from the different applications we deployed in 2020 and rationalizes them into a practice we hope to establish with the community in 2021. Our goal is to empower a community of participants and contributors within which Microsoft takes part in and provides architectural and implementation guidance, but is fundamentally driven by the needs of the community in establishing the best ways to implement end-to-end verifiable elections and post-election audits. We took our first step toward this new vision with the release of the electionguard-cpp ballot-encryption repo last week. Combined with the electionguard-python repo that implements the full suite of ElectionGuard SDK functionality and the base electionguard specification and documentation repo, we have laid the foundation for our future direction. Our goal for the first half of 2021 is to have a full suite of code, tests, workflows, and package deployments more directly associated with the conventions and requirements indicated by the specification. We plan to publish and generate both more comprehensive but also granular examples and use cases to enable easier and more focused contributions by the community as well. We will also continue to enthusiastically support innovative pilot opportunities exemplifying end-to-end verifiable elections and post-election audits. Join our monthly calls , post ideas and issues, and otherwise let us know how ElectionGuard can help improve trust in elections. 1.0 Specification a final, fully-developed specification integrated directly into the SDK; updates to election manifest and election artifact descriptions and specifications a more modular approach to documentation and contribution to lessen the learning curve and overhead necessary to participate and contribute more prescriptive guidance on verifier construction C++ ballot encryption library repo that performs encryption exclusively (for embedded encryption applications such as precinct scanners) standalone source that uses a version of HACL* packaged up by EverCrypt for high assurance (thank you EverCrypt team!) enables ElectionGuard to eliminate GMP as a dependency Release an ElectionGuard.Encrypt nuget package built from electionguard-cpp as a ballot encrypter for low performance devices Establish publishing pattern First target will be Windows 10 / UWP A consistent, efficient set of data interfaces across the ElectionGuard, C++, and Python repos Data serialization using Protobuf for input/output/data consistency across electionguard-cpp and electionguard-python Restructuring ballot and device aggregation to better support audits and scalability in general Renaming and refactoring all repos for more descriptive and specific naming patterns Compose community changes into electionguard-python release v1.1.16 Optimization changes for service implementations of electionguard-python release v1.2.0 Introduce service docker containers in electionguard-api Migrate 0.95 specification to Github Implement specification in diffable, searchable format in Github Adopt mkdocs material template for documentation and integrate with remaining ElectionGuard guide 2020 In Review 2020 taught many lessons. In the first half of the year, after our successful Fulton, WI Election Pilot with VotingWorks and InfernoRed as well as feedback from our Bounty Program , we chose to migrate from the C library we released in September 2019 to Python and establish a revamped reference implementation in a language suitable for translation into multiple other languages. (As such, our implementation doesn't focus on Pythonic optimizations necessarily, but emphasizes structures and practices replicable across many languages.) In the second half of the year , responding to COVID caused us to develop a remote voting app with InfernoRed , Markup , and the US House Democratic Caucus to enable representatives to vote by secret ballot safely, securely, and remotely for Caucus leadership positions . We also worked with the Canadian voting company Neuvote to showcase their electronic- and remote-paper-based system in Brazil as part of a demonstration of future voting system options. We also had the opportunity to further collaborate with VotingWorks, this time on post-election audits. Driven principally by Rice University professor Dan Wallach's work with Arlo , ElectionGuard provided the \"back end\" for Inyo County's Risk-limiting Audit of the November 3 election . Last and definitely not least, we had our first independent verifiers developed and published . We thank all our collaborators and contributors for their contributions, of course, but also how they're informing our future direction. 2020 Roadmap Use ElectionGuard in a real-world end-to-end verifiable election Run a verifiable election Fulton, Wisconsin with VotingWorks using smart cards, a ballot box, an admin device, and a ballot tracking site. Integrate ElectionGuard with the VotingWorks print station and user flow Build ballot box functionality to capture and seal ballots Build admin device to enable tallies and key ceremonies Build tracking site to enable verification code lookup and tally/results download Use ElectionGuard in a real-world post-election audit Run a post-election election audit with Inyo, California using VotingWorks Arlo using ElectionGuard as a back end Identify learnings and code refactoring necessary to reflect the different data structures and scalability considerations of audits Update the ElectionGuard specification to 0.95.0 Support building ElectionGuard into additional voting systems Enable remote, secret-ballot voting for Democratic Caucus of the US House of Representatives Work with InfernoRed and Markup to enable House-distributed iPhones to perform ballot encryption and House Democratic leadership to schedule and tally secret-ballot elections for leadership and committee positions Release and iterate on electionguard-python as a core implementation that meets specification 0.95.0 Implement a canonical library addressing all ElectionGuard SDK functionality: Key generation Ballot encryption Ballot sealing Tally generation Verifier specification Build library with an eye to extensibility rather than performance and local language optimization (i.e., we'll be less Pythonic than some might prefer for the base implementation) Integrate ElectionGuard into a set of election tools 2019 Roadmap Initial specification and electionguard-c release Demonstrate ElectionGuard Reference Implementation at Aspen Security Conference","title":"Roadmap"},{"location":"Roadmap/#electionguard-roadmap","text":"","title":"ElectionGuard Roadmap"},{"location":"Roadmap/#2021-roadmap","text":"Our 2021 roadmap takes the learnings from the different applications we deployed in 2020 and rationalizes them into a practice we hope to establish with the community in 2021. Our goal is to empower a community of participants and contributors within which Microsoft takes part in and provides architectural and implementation guidance, but is fundamentally driven by the needs of the community in establishing the best ways to implement end-to-end verifiable elections and post-election audits. We took our first step toward this new vision with the release of the electionguard-cpp ballot-encryption repo last week. Combined with the electionguard-python repo that implements the full suite of ElectionGuard SDK functionality and the base electionguard specification and documentation repo, we have laid the foundation for our future direction. Our goal for the first half of 2021 is to have a full suite of code, tests, workflows, and package deployments more directly associated with the conventions and requirements indicated by the specification. We plan to publish and generate both more comprehensive but also granular examples and use cases to enable easier and more focused contributions by the community as well. We will also continue to enthusiastically support innovative pilot opportunities exemplifying end-to-end verifiable elections and post-election audits. Join our monthly calls , post ideas and issues, and otherwise let us know how ElectionGuard can help improve trust in elections. 1.0 Specification a final, fully-developed specification integrated directly into the SDK; updates to election manifest and election artifact descriptions and specifications a more modular approach to documentation and contribution to lessen the learning curve and overhead necessary to participate and contribute more prescriptive guidance on verifier construction C++ ballot encryption library repo that performs encryption exclusively (for embedded encryption applications such as precinct scanners) standalone source that uses a version of HACL* packaged up by EverCrypt for high assurance (thank you EverCrypt team!) enables ElectionGuard to eliminate GMP as a dependency Release an ElectionGuard.Encrypt nuget package built from electionguard-cpp as a ballot encrypter for low performance devices Establish publishing pattern First target will be Windows 10 / UWP A consistent, efficient set of data interfaces across the ElectionGuard, C++, and Python repos Data serialization using Protobuf for input/output/data consistency across electionguard-cpp and electionguard-python Restructuring ballot and device aggregation to better support audits and scalability in general Renaming and refactoring all repos for more descriptive and specific naming patterns Compose community changes into electionguard-python release v1.1.16 Optimization changes for service implementations of electionguard-python release v1.2.0 Introduce service docker containers in electionguard-api Migrate 0.95 specification to Github Implement specification in diffable, searchable format in Github Adopt mkdocs material template for documentation and integrate with remaining ElectionGuard guide","title":"2021 Roadmap"},{"location":"Roadmap/#2020-in-review","text":"2020 taught many lessons. In the first half of the year, after our successful Fulton, WI Election Pilot with VotingWorks and InfernoRed as well as feedback from our Bounty Program , we chose to migrate from the C library we released in September 2019 to Python and establish a revamped reference implementation in a language suitable for translation into multiple other languages. (As such, our implementation doesn't focus on Pythonic optimizations necessarily, but emphasizes structures and practices replicable across many languages.) In the second half of the year , responding to COVID caused us to develop a remote voting app with InfernoRed , Markup , and the US House Democratic Caucus to enable representatives to vote by secret ballot safely, securely, and remotely for Caucus leadership positions . We also worked with the Canadian voting company Neuvote to showcase their electronic- and remote-paper-based system in Brazil as part of a demonstration of future voting system options. We also had the opportunity to further collaborate with VotingWorks, this time on post-election audits. Driven principally by Rice University professor Dan Wallach's work with Arlo , ElectionGuard provided the \"back end\" for Inyo County's Risk-limiting Audit of the November 3 election . Last and definitely not least, we had our first independent verifiers developed and published . We thank all our collaborators and contributors for their contributions, of course, but also how they're informing our future direction.","title":"2020 In Review"},{"location":"Roadmap/#2020-roadmap","text":"Use ElectionGuard in a real-world end-to-end verifiable election Run a verifiable election Fulton, Wisconsin with VotingWorks using smart cards, a ballot box, an admin device, and a ballot tracking site. Integrate ElectionGuard with the VotingWorks print station and user flow Build ballot box functionality to capture and seal ballots Build admin device to enable tallies and key ceremonies Build tracking site to enable verification code lookup and tally/results download Use ElectionGuard in a real-world post-election audit Run a post-election election audit with Inyo, California using VotingWorks Arlo using ElectionGuard as a back end Identify learnings and code refactoring necessary to reflect the different data structures and scalability considerations of audits Update the ElectionGuard specification to 0.95.0 Support building ElectionGuard into additional voting systems Enable remote, secret-ballot voting for Democratic Caucus of the US House of Representatives Work with InfernoRed and Markup to enable House-distributed iPhones to perform ballot encryption and House Democratic leadership to schedule and tally secret-ballot elections for leadership and committee positions Release and iterate on electionguard-python as a core implementation that meets specification 0.95.0 Implement a canonical library addressing all ElectionGuard SDK functionality: Key generation Ballot encryption Ballot sealing Tally generation Verifier specification Build library with an eye to extensibility rather than performance and local language optimization (i.e., we'll be less Pythonic than some might prefer for the base implementation) Integrate ElectionGuard into a set of election tools","title":"2020 Roadmap"},{"location":"Roadmap/#2019-roadmap","text":"Initial specification and electionguard-c release Demonstrate ElectionGuard Reference Implementation at Aspen Security Conference","title":"2019 Roadmap"},{"location":"guide/Core_Component/","text":"There are various implementations of the core component of the ElectionGuard SDK. This piece performs election functions such as vote encryption, decryption, key generation, and tallying. This code is meant to be run on voting system hardware and to be integrated into existing (or new) voting system software. The ElectionGuard SDK is meant to add end-to-end verifiability and encryption into 3rd party comprehensive voting systems. There are provided simplistic, proof-of-concept applications to understand how each implementation of the API should be called. Currently, there are two available implementations. Python Includes: Key Generation, Ballot Encryption, Tallying, Decryption Source | Package | Documentation C ++ Includes: Ballot Encryption Source - \u2728 Coming Soon Community Java Includes: Key Generation, Ballot Encryption, Tallying, Decryption Source Archived Danger The following versions and their dependent repositories are considered deprecated. For active development, please use a non-archived version instead. C Source C# Source | Package","title":"Core Component"},{"location":"guide/Core_Component/#python","text":"Includes: Key Generation, Ballot Encryption, Tallying, Decryption Source | Package | Documentation","title":"Python"},{"location":"guide/Core_Component/#c","text":"Includes: Ballot Encryption Source - \u2728 Coming Soon","title":"C ++"},{"location":"guide/Core_Component/#community","text":"","title":"Community"},{"location":"guide/Core_Component/#java","text":"Includes: Key Generation, Ballot Encryption, Tallying, Decryption Source","title":"Java"},{"location":"guide/Core_Component/#archived","text":"Danger The following versions and their dependent repositories are considered deprecated. For active development, please use a non-archived version instead.","title":"Archived"},{"location":"guide/Core_Component/#c_1","text":"Source","title":"C"},{"location":"guide/Core_Component/#c_2","text":"Source | Package","title":"C#"},{"location":"guide/Election_Manifest/","text":"Election Manifest There are many types of elections. We need a base set of data that shows how these different types of elections are handled in an ElectionGuard end-to-end verifiable election (or ballot comparison audits). We worked with InfernoRed, VotingWorks, and Dan Wallach of Rice University (thanks folks!) to develop a set of conventions, tests, and sample data (based on a starting dataset sample from the Center for Civic Design) that demonstrate how to encode the information necessary to conduct an election into a format that ElectionGuard can use. The election terms and structure are based whenever possible on the NIST SP-1500-100 Election Results Common Data Format Specification ( PDF ) and the Civics Common Standard Data Specification . The information captured by the NIST standard is codified into an election manifest that defines common elements when conducting an election, such as locations, candidates, parties, contests, and ballot styles. ElectionGuard uses the data contained in the Election Manifest to associate ballots with specific ballot styles and to verify the accuracy of data at different stages of the election process. Note that not all of the data contained in the Election Manifest impacts the computations of tallies and zero-knowledge proofs used in the published election data that demonstrates end-to-end verifiability; however it is important to include as much data as possible in order to distinguish one election from another. With a well-defined Election Manifest, improperly formatted ballot encryption requests will fail with error messages at the moment of initial encryption; the enforcement of any logic or behavior to prevent overvoting or other malformed ballot submissions are handled by the encrypting device, not ElectionGuard. In addition, since json files do not accommodate comments, all notations and exceptions are documented in this readme. Election Data Structure Elections are characterized into types by NIST as shown in the table below election type description general For an election held typically on the national day for elections. partisan-primary-closed For a primary election that is for a specific party where voter eligibility is based on registration. partisan-primary-open For a primary election that is for a specific party where voter declares desired party or chooses in private. primary For a primary election without a specified type, such as a nonpartisan primary. runoff For an election to decide a prior contest that ended with no candidate receiving a majority of the votes. special For an election held out of sequence for special circumstances, for example, to fill a vacated office. other Used when the election type is not listed in this enumeration. If used, include a specific value of the OtherType element. We present two sample manifests: general and partisan-primary-closed . The core distinction between the two samples is the role of party: in general elections voters can choose to vote for candidates from any party in a contest, regardless of party affiliation. In partisan primaries voters can only vote in contests germane to their party declaration or affiliation. As such, special , runoff , and primary election types will follow the general pattern, and partisan-primary-open will follow the partisan-primary-closed pattern. Open primary elections can follow either pattern as determined by their governing rules and regulations. (As noted above, ElectionGuard expects properly-formed ballots; e.g., it would error and fail to encrypt a ballot in an open-primary-closed election if a contest with an incorrect party affiliation were submitted (as indicated by the ).) Ballot Styles and Geography At least in the United States, many complications are introduced by voting simultaneously on election contests that apply in specific geographies and jurisdictions. For example, a single election could include contests for congress, state assembly, school, and utility districts, each with their own geographic boundaries, many that do not respect town or county lines. The ElectionGuard Election Manifest data format is flexible to accommodate most situations, but it is usually up to the election commission and the external system to determine what each component of the manifest actually means. In the following examples, we will work through the process of defining different election types at a high level and describe the process of building the election manifest. Geographic and Ballot Style Breakdown Each election can be thought of as a list of contests that are relevant to a certain group of people in a specific place. In order to determine who is supposed to vote on which contests, we first need to define the geographic jurisdictions where the election is taking place. The NIST Guidelines present an excellent discussion of the geographic interplay of different contests. The diagram from page 12 is presented below. As the diagram shows, congressional, state assembly, school district and other geographic boundaries project onto towns and municipalities in different ways. Elections manage this complexity by creating unique ballot styles that present to voters only the contests that pertain to them. Different jurisdictions use terms such as wards, precincts, and districts to describe the areas of overlap that guide ballot style creation. We will use precinct but ward and district could be used instead. Contests, Candidates and Parties In most cases, a resident of a specific precinct or location will expect to see a certain list of contests that are relevant to them. A contest is a specific collection of available choices ( selections ) from which the voter may choose some subset. For the ElectionGuard Election Manifest, each possible selection in a contest must be associated with a candidate, even for Referendum-style contests. If a contest also supports write-in values, then a write-in candidate is also defined. Candidates may also be associated with specific parties, but this is not required for all election types. Introducing Hamilton County, OZ To help disambiguate, let's explore an example. Geographic Jurisdictions Hamilton County includes 3 townships: LaCroix, Arlington, Harris. The town of LaCroix also has a utility district that comprises its own precinct for special referendums. Arlington has two distinct school districts. The county is also split into two congressional districts, district 5 and district 7. Harris township is entirely within Congressional District 5, but both LaCroix and Arlington are split between congressional districts 5 and 7. Building the Geographic Jurisdiction Mapping (Geopolitical Units) The Election Manifest includes an array of objects called geopoliticalUnits (a.k.a. gpUnit ). Each Geopolitical Unit must include the following fields: objectId - a unique identifier for the gpUnit. This value is used to map a contest to a specific jurisdiction name - the friendly name of the gp Unit type - they type of jurisdiction (one of the Reporting Unit Types ) contact information - the contact info for the geopolitical unit Geopolitical units are polygons on a map represented by legal jurisdictions. In our example Election Manifest for hamilton County, there is one geopolitical unit for each jurisdictional boundary in the image above: Hamilton County Congressional District 5 congressional District 7 LaCroix Township Exeter Utility District (within LaCroix Township) Harris Township Arlington Township Pismo Beach School District (within Arlington Township) Somerset School District (within Arlington Township) When defining the geopolitical units for an election, we define all of the possible geopolitical units for an election; even if there are no contests for a specific jurisdiction. This way, if contests are added or removed during the setup phase, you do not also have to remember to update the list of geopolitical units. Alternatively, you can define only the GP Units for which there are contests. The General Election Contests A general election will occur in Hamilton County. The county is voting along with the rest of the province, and the county is responsible for tabulating its own election results. This means that the Election Scope is defined at the county level. For the general election, the following sets of contests (and associated geographic boundaries) obtain: The National Contests - President and Vice President. This contest demonstrates a \"vote for the ticket\" and allows write-ins Province Contests - Governor - this contest demonstrates a long list of candidate names Congressional Contests - Congress Districts 5 and 7 - these contests demonstrate how to split a district using multiple ballot styles Township Contests - Retain Chief Justice - This contest demonstrates a contest that applies to a specific town whose boundaries are split across multiple ballot styles School District Contests - School Board - these contests demonstrate contests with multiple selections ( n-of-m ) and allow write-ins School Board, and Utility district referendum to show ballot style splits Utility District Contest - Utility District - This contest demonstrates a referendum-style contest with long descriptions and display language translation into Spanish Each contest must be associated with exactly ONE electoralDistrictId . The electoralDistrictId field on the contest is populated with the objectId of the associated Geopolitical Unit (e.g. the Contest congress-district-7-contest has the electoralDistrictId congress-district-7 Each contest must also define a sequenceOrder . the sequence order is an indexing mechanism used internally. It is not the sequence that the contests are displayed to the user . The order in which contests are displayed to the user is up to the implementing application. The General Election Ballot Styles A ballot style is the set of contests that a specific voter should see on their ballot for a given location. The ballot style is associated to the set of geopolitical units relevant to a specific point on a map. Since each contest is also associated with a geopolitical unit, a mapping is created between a point on a map and the contests that are relevant to that point. For instance, a voter that lives in the Exeter Utility District should see contests that are relevant to Congressional District 7, LaCroix Township and the Exeter Utility District. | Geopolitical Units are overlapping polygons, and ballot styles are the list of polygons relevant to a specific point on the map. Similar to Geopolitical Units, we define all of the possible ballot styles for an election in our example, even if there are no contests specific to a ballot style. This is subjective and the behavior may be different for the integrating system: Congressional District 7 Outside Any Township Congressional District 7 LaCroix Township Congressional District 7 LaCroix Township Exeter Utility District Congressional District 7 Arlington Township Congressional District 7 Arlington Township Pismo Beach School district Congressional District 7 Arlington Township Somerset School district Congressional District 5 Outside Any Township Congressional District 5 LaCroix Township Congressional District 5 Harris Township Congressional District 5 Arlington Township Pismo Beach School district Congressional District 5 Arlington Township Somerset School district By defining all of the possible ballot styles and all of the possible geopolitical units, we ensure that if a contest is added or removed, we only have to make sure the contest is correct. We do not have to modify the list of geopolitical units or ballot styles. Data Flexibility The relationship between a ballot style and the contests that are displayed on it are subjective to the implementing application. This example is just one way to define this relationship that is purposefully verbose. For instance, in our example we define a geopolitical unit as a set of overlapping polygons, and a ballot style as the intersection of those polygons at a specific point. This is a top-down approach. Alternatively, we could have defined a geopolitical unit as the intersection area of those polygons and mapped one ballot style to each geopolitical unit 1 to 1. for instance, instead of defining a single GP Unit each for: Congressional District 5, Congressional District 7, LaCroix Township, Exeter Utility district, etc; we could have instead defined the GP Units as: Congressional District 5 No Township Congressional District 7 No Township Congressional District 5 inside LaCroix Congressional District 5 Inside LaCroix and Exeter, etc. Then, instead of each Ballot Style having multiple GP Units, each ballot style would have applied to exactly one GP Unit. Data Validation When the election Manifest is loaded into ElectionGuard, its validity is checked semantically against the data format required to conduct an ElectionGuard Election. Specifically, we check that: Each Geopolitical Unit has a unique objectId Each Ballot Style maps to at least one valid Geopolitical Unit Each Party has a unique objectId Each Candidate either does not have a party, or is associated with a valid party Each Contest has a unique Sequence Order Each contest is associated with exactly one valid geopolitical unit Each contest has a valid number of selections for the number of seats in the contest Each selection on each contest is associated with a valid Candidate as long as the election manifest format matches the validation criteria, the election can proceed as an ElectionGuard election. Frequently Asked Questions Q: What if my ballot styles are not associated with geopolitical units? A: There are a few ways to handle this. In most cases, you can simply map the ballot style 1 to 1 to the geopolitical unit. for instance, if ballot-style-1 includes contest-1 then you may create geopolitical-unit-1 and associate both the ballot style and the contest to that geopolitical unit. This documentation is under review and subject to change. Please do not hesitate to open a github issue if you have questions, or find errors or omissions.","title":"Election Manifest"},{"location":"guide/Election_Manifest/#election-manifest","text":"There are many types of elections. We need a base set of data that shows how these different types of elections are handled in an ElectionGuard end-to-end verifiable election (or ballot comparison audits). We worked with InfernoRed, VotingWorks, and Dan Wallach of Rice University (thanks folks!) to develop a set of conventions, tests, and sample data (based on a starting dataset sample from the Center for Civic Design) that demonstrate how to encode the information necessary to conduct an election into a format that ElectionGuard can use. The election terms and structure are based whenever possible on the NIST SP-1500-100 Election Results Common Data Format Specification ( PDF ) and the Civics Common Standard Data Specification . The information captured by the NIST standard is codified into an election manifest that defines common elements when conducting an election, such as locations, candidates, parties, contests, and ballot styles. ElectionGuard uses the data contained in the Election Manifest to associate ballots with specific ballot styles and to verify the accuracy of data at different stages of the election process. Note that not all of the data contained in the Election Manifest impacts the computations of tallies and zero-knowledge proofs used in the published election data that demonstrates end-to-end verifiability; however it is important to include as much data as possible in order to distinguish one election from another. With a well-defined Election Manifest, improperly formatted ballot encryption requests will fail with error messages at the moment of initial encryption; the enforcement of any logic or behavior to prevent overvoting or other malformed ballot submissions are handled by the encrypting device, not ElectionGuard. In addition, since json files do not accommodate comments, all notations and exceptions are documented in this readme.","title":"Election Manifest"},{"location":"guide/Election_Manifest/#election-data-structure","text":"Elections are characterized into types by NIST as shown in the table below election type description general For an election held typically on the national day for elections. partisan-primary-closed For a primary election that is for a specific party where voter eligibility is based on registration. partisan-primary-open For a primary election that is for a specific party where voter declares desired party or chooses in private. primary For a primary election without a specified type, such as a nonpartisan primary. runoff For an election to decide a prior contest that ended with no candidate receiving a majority of the votes. special For an election held out of sequence for special circumstances, for example, to fill a vacated office. other Used when the election type is not listed in this enumeration. If used, include a specific value of the OtherType element. We present two sample manifests: general and partisan-primary-closed . The core distinction between the two samples is the role of party: in general elections voters can choose to vote for candidates from any party in a contest, regardless of party affiliation. In partisan primaries voters can only vote in contests germane to their party declaration or affiliation. As such, special , runoff , and primary election types will follow the general pattern, and partisan-primary-open will follow the partisan-primary-closed pattern. Open primary elections can follow either pattern as determined by their governing rules and regulations. (As noted above, ElectionGuard expects properly-formed ballots; e.g., it would error and fail to encrypt a ballot in an open-primary-closed election if a contest with an incorrect party affiliation were submitted (as indicated by the ).)","title":"Election Data Structure"},{"location":"guide/Election_Manifest/#ballot-styles-and-geography","text":"At least in the United States, many complications are introduced by voting simultaneously on election contests that apply in specific geographies and jurisdictions. For example, a single election could include contests for congress, state assembly, school, and utility districts, each with their own geographic boundaries, many that do not respect town or county lines. The ElectionGuard Election Manifest data format is flexible to accommodate most situations, but it is usually up to the election commission and the external system to determine what each component of the manifest actually means. In the following examples, we will work through the process of defining different election types at a high level and describe the process of building the election manifest.","title":"Ballot Styles and Geography"},{"location":"guide/Election_Manifest/#geographic-and-ballot-style-breakdown","text":"Each election can be thought of as a list of contests that are relevant to a certain group of people in a specific place. In order to determine who is supposed to vote on which contests, we first need to define the geographic jurisdictions where the election is taking place. The NIST Guidelines present an excellent discussion of the geographic interplay of different contests. The diagram from page 12 is presented below. As the diagram shows, congressional, state assembly, school district and other geographic boundaries project onto towns and municipalities in different ways. Elections manage this complexity by creating unique ballot styles that present to voters only the contests that pertain to them. Different jurisdictions use terms such as wards, precincts, and districts to describe the areas of overlap that guide ballot style creation. We will use precinct but ward and district could be used instead.","title":"Geographic and Ballot Style Breakdown"},{"location":"guide/Election_Manifest/#contests-candidates-and-parties","text":"In most cases, a resident of a specific precinct or location will expect to see a certain list of contests that are relevant to them. A contest is a specific collection of available choices ( selections ) from which the voter may choose some subset. For the ElectionGuard Election Manifest, each possible selection in a contest must be associated with a candidate, even for Referendum-style contests. If a contest also supports write-in values, then a write-in candidate is also defined. Candidates may also be associated with specific parties, but this is not required for all election types.","title":"Contests, Candidates and Parties"},{"location":"guide/Election_Manifest/#introducing-hamilton-county-oz","text":"To help disambiguate, let's explore an example.","title":"Introducing Hamilton County, OZ"},{"location":"guide/Election_Manifest/#geographic-jurisdictions","text":"Hamilton County includes 3 townships: LaCroix, Arlington, Harris. The town of LaCroix also has a utility district that comprises its own precinct for special referendums. Arlington has two distinct school districts. The county is also split into two congressional districts, district 5 and district 7. Harris township is entirely within Congressional District 5, but both LaCroix and Arlington are split between congressional districts 5 and 7.","title":"Geographic Jurisdictions"},{"location":"guide/Election_Manifest/#building-the-geographic-jurisdiction-mapping-geopolitical-units","text":"The Election Manifest includes an array of objects called geopoliticalUnits (a.k.a. gpUnit ). Each Geopolitical Unit must include the following fields: objectId - a unique identifier for the gpUnit. This value is used to map a contest to a specific jurisdiction name - the friendly name of the gp Unit type - they type of jurisdiction (one of the Reporting Unit Types ) contact information - the contact info for the geopolitical unit Geopolitical units are polygons on a map represented by legal jurisdictions. In our example Election Manifest for hamilton County, there is one geopolitical unit for each jurisdictional boundary in the image above: Hamilton County Congressional District 5 congressional District 7 LaCroix Township Exeter Utility District (within LaCroix Township) Harris Township Arlington Township Pismo Beach School District (within Arlington Township) Somerset School District (within Arlington Township) When defining the geopolitical units for an election, we define all of the possible geopolitical units for an election; even if there are no contests for a specific jurisdiction. This way, if contests are added or removed during the setup phase, you do not also have to remember to update the list of geopolitical units. Alternatively, you can define only the GP Units for which there are contests.","title":"Building the Geographic Jurisdiction Mapping (Geopolitical Units)"},{"location":"guide/Election_Manifest/#the-general-election-contests","text":"A general election will occur in Hamilton County. The county is voting along with the rest of the province, and the county is responsible for tabulating its own election results. This means that the Election Scope is defined at the county level. For the general election, the following sets of contests (and associated geographic boundaries) obtain: The National Contests - President and Vice President. This contest demonstrates a \"vote for the ticket\" and allows write-ins Province Contests - Governor - this contest demonstrates a long list of candidate names Congressional Contests - Congress Districts 5 and 7 - these contests demonstrate how to split a district using multiple ballot styles Township Contests - Retain Chief Justice - This contest demonstrates a contest that applies to a specific town whose boundaries are split across multiple ballot styles School District Contests - School Board - these contests demonstrate contests with multiple selections ( n-of-m ) and allow write-ins School Board, and Utility district referendum to show ballot style splits Utility District Contest - Utility District - This contest demonstrates a referendum-style contest with long descriptions and display language translation into Spanish Each contest must be associated with exactly ONE electoralDistrictId . The electoralDistrictId field on the contest is populated with the objectId of the associated Geopolitical Unit (e.g. the Contest congress-district-7-contest has the electoralDistrictId congress-district-7 Each contest must also define a sequenceOrder . the sequence order is an indexing mechanism used internally. It is not the sequence that the contests are displayed to the user . The order in which contests are displayed to the user is up to the implementing application.","title":"The General Election Contests"},{"location":"guide/Election_Manifest/#the-general-election-ballot-styles","text":"A ballot style is the set of contests that a specific voter should see on their ballot for a given location. The ballot style is associated to the set of geopolitical units relevant to a specific point on a map. Since each contest is also associated with a geopolitical unit, a mapping is created between a point on a map and the contests that are relevant to that point. For instance, a voter that lives in the Exeter Utility District should see contests that are relevant to Congressional District 7, LaCroix Township and the Exeter Utility District. | Geopolitical Units are overlapping polygons, and ballot styles are the list of polygons relevant to a specific point on the map. Similar to Geopolitical Units, we define all of the possible ballot styles for an election in our example, even if there are no contests specific to a ballot style. This is subjective and the behavior may be different for the integrating system: Congressional District 7 Outside Any Township Congressional District 7 LaCroix Township Congressional District 7 LaCroix Township Exeter Utility District Congressional District 7 Arlington Township Congressional District 7 Arlington Township Pismo Beach School district Congressional District 7 Arlington Township Somerset School district Congressional District 5 Outside Any Township Congressional District 5 LaCroix Township Congressional District 5 Harris Township Congressional District 5 Arlington Township Pismo Beach School district Congressional District 5 Arlington Township Somerset School district By defining all of the possible ballot styles and all of the possible geopolitical units, we ensure that if a contest is added or removed, we only have to make sure the contest is correct. We do not have to modify the list of geopolitical units or ballot styles.","title":"The General Election Ballot Styles"},{"location":"guide/Election_Manifest/#data-flexibility","text":"The relationship between a ballot style and the contests that are displayed on it are subjective to the implementing application. This example is just one way to define this relationship that is purposefully verbose. For instance, in our example we define a geopolitical unit as a set of overlapping polygons, and a ballot style as the intersection of those polygons at a specific point. This is a top-down approach. Alternatively, we could have defined a geopolitical unit as the intersection area of those polygons and mapped one ballot style to each geopolitical unit 1 to 1. for instance, instead of defining a single GP Unit each for: Congressional District 5, Congressional District 7, LaCroix Township, Exeter Utility district, etc; we could have instead defined the GP Units as: Congressional District 5 No Township Congressional District 7 No Township Congressional District 5 inside LaCroix Congressional District 5 Inside LaCroix and Exeter, etc. Then, instead of each Ballot Style having multiple GP Units, each ballot style would have applied to exactly one GP Unit.","title":"Data Flexibility"},{"location":"guide/Election_Manifest/#data-validation","text":"When the election Manifest is loaded into ElectionGuard, its validity is checked semantically against the data format required to conduct an ElectionGuard Election. Specifically, we check that: Each Geopolitical Unit has a unique objectId Each Ballot Style maps to at least one valid Geopolitical Unit Each Party has a unique objectId Each Candidate either does not have a party, or is associated with a valid party Each Contest has a unique Sequence Order Each contest is associated with exactly one valid geopolitical unit Each contest has a valid number of selections for the number of seats in the contest Each selection on each contest is associated with a valid Candidate as long as the election manifest format matches the validation criteria, the election can proceed as an ElectionGuard election.","title":"Data Validation"},{"location":"guide/Election_Manifest/#frequently-asked-questions","text":"Q: What if my ballot styles are not associated with geopolitical units? A: There are a few ways to handle this. In most cases, you can simply map the ballot style 1 to 1 to the geopolitical unit. for instance, if ballot-style-1 includes contest-1 then you may create geopolitical-unit-1 and associate both the ballot style and the contest to that geopolitical unit. This documentation is under review and subject to change. Please do not hesitate to open a github issue if you have questions, or find errors or omissions.","title":"Frequently Asked Questions"},{"location":"guide/Getting_Started/","text":"Getting Started There are many places to start start in ElectionGuard. If you're looking to develop see below, if you just want to research see the rest of the guide. SDK The ElectionGuard software development kit (SDK) contains two major parts. The core component for developing with ElectionGuard and reference implementations that interact with core component or provide a peek into the pieces required for the election process. Latest These are the latest projects from ElectionGuard. If you're looking to contribute, these are the best places to start. electionguard-python electionguard-web-api Language Pick your language of preference: Specifications These documents contains the fundamental specifications, documentation, architecture, and mathematical/cryptographic proofs that underpin ElectionGuard. If you're looking to understand the system better, or want to know how to integrate the various components, there is a lot of valuable information contained here.","title":"Getting Started"},{"location":"guide/Getting_Started/#getting-started","text":"There are many places to start start in ElectionGuard. If you're looking to develop see below, if you just want to research see the rest of the guide.","title":"Getting Started"},{"location":"guide/Getting_Started/#sdk","text":"The ElectionGuard software development kit (SDK) contains two major parts. The core component for developing with ElectionGuard and reference implementations that interact with core component or provide a peek into the pieces required for the election process.","title":"SDK"},{"location":"guide/Getting_Started/#latest","text":"These are the latest projects from ElectionGuard. If you're looking to contribute, these are the best places to start. electionguard-python electionguard-web-api","title":"Latest"},{"location":"guide/Getting_Started/#language","text":"Pick your language of preference:","title":"Language"},{"location":"guide/Getting_Started/#specifications","text":"These documents contains the fundamental specifications, documentation, architecture, and mathematical/cryptographic proofs that underpin ElectionGuard. If you're looking to understand the system better, or want to know how to integrate the various components, there is a lot of valuable information contained here.","title":"Specifications"},{"location":"guide/Glossary/","text":"ElectionGuard Glossary Overview ElectionGuard, end-to-end verifiability, and elections themselves use a variety of terms in the conductance of an election, as well as the encryption, tally, and publishing thereof. Many of these terms have variants used in different locales. Given the potential ambiguity of terminology, we present this Glossary. It states the precise meaning and usage of the terms used by the ElectionGuard SDK and related specifications and tools. Whenever possible, we used terms and meanings consistent the NIST Elections Guide . Terms Accepted Ballot A ballot that is accepted for inclusion in election results and is either: cast or spoiled. Auxiliary Key Pair Pair of keys (public & secret) used to encrypt/decrypt information sent between guardians Available Guardian A guardian that has announced as present for the decryption phase Ballot Box A collection of ballots that have been either cast or spoiled. Cast Ballot A ballot which a voter has accepted as valid to be included in the official election tally. Ciphertext Ballot An encrypted representation of a voter's filled-in ballot. Ciphertext Election Context The cryptographic context of an election that is configured during the Key Ceremony Compensated Decryption Share A partial decryption share value computed by an available guardian to compensate for a missing guardian so that the missing guardian's share can be generated and the election results can be successfully decrypted. Description Hash A hash representation of the original election description. Decryption Mediator A component or actor responsible for composing each guardian's partial decryptions or compensated decryptions into the plaintext tally Decryption Share A guardian's partial share of a decryption Election Description The election metadata that describes the structure and type of the election, including geopolitical units, contests, candidates, and ballot styles, etc. Encryption Device The device that is doing the encryption Election Key Pair Pair of keys (public & secret) used to encrypt/decrypt election Election Manifest The election metadata in json format that is parsed into an Election Description Election Partial Key Backup A point on a secret polynomial and commitments to verify this point for a designated guardian. Election Polynomial The election polynomial is the mathematical expression that each Guardian defines to solve for his or her private key. A different point associated with the polynomial is shared with each of the other guardians so that the guardians can come together to derive the polynomial function and solve for the private key. Encrypted Tally The homomorphically-combined and encrypted representation of all selections made for each option on every contest in the election. Guardian A guardian of the election who holds the ability to partially decrypt the election results Homomorphic Tally An encrypted representation of every selection on every ballot that was cast. Internal Election Description The subset of the election description required by ElectionGuard to validate ballots are correctly associated with an election. This component mutates the state of the Election Description. Joint Key Combined public key from election public keys of each guardian Key Ceremony The process conducted at the beginning of the election to create the joint encryption context for encrypting ballots during the election. Key Ceremony Mediator A mediator to mediate communication (if needed) of information such as keys between the guardians Missing Guardian A guardian who was configured during the Key Ceremony but who is not present for the decryption of the election results. Nonce A random number used to derive encryptions Plaintext Ballot The plaintext representation of a voter's selections Quorum The minimum count ( threshold ) of guardians that must be present in order to successfully decrypt the election results. Spoiled Ballot A ballot which a voter did not accept as valid and is not included in the tally. Tracking Code A unique hash value generated by an Encryption Device to anonymously identify a ballot Unknown Ballot A ballot which may not yet be determined as cast or spoiled, or that may have been spoiled but is otherwise not published in the election results.","title":"Glossary"},{"location":"guide/Glossary/#electionguard-glossary","text":"","title":"ElectionGuard Glossary"},{"location":"guide/Glossary/#overview","text":"ElectionGuard, end-to-end verifiability, and elections themselves use a variety of terms in the conductance of an election, as well as the encryption, tally, and publishing thereof. Many of these terms have variants used in different locales. Given the potential ambiguity of terminology, we present this Glossary. It states the precise meaning and usage of the terms used by the ElectionGuard SDK and related specifications and tools. Whenever possible, we used terms and meanings consistent the NIST Elections Guide .","title":"Overview"},{"location":"guide/Glossary/#terms","text":"","title":"Terms"},{"location":"guide/Glossary/#accepted-ballot","text":"A ballot that is accepted for inclusion in election results and is either: cast or spoiled.","title":"Accepted Ballot"},{"location":"guide/Glossary/#auxiliary-key-pair","text":"Pair of keys (public & secret) used to encrypt/decrypt information sent between guardians","title":"Auxiliary Key Pair"},{"location":"guide/Glossary/#available-guardian","text":"A guardian that has announced as present for the decryption phase","title":"Available Guardian"},{"location":"guide/Glossary/#ballot-box","text":"A collection of ballots that have been either cast or spoiled.","title":"Ballot Box"},{"location":"guide/Glossary/#cast-ballot","text":"A ballot which a voter has accepted as valid to be included in the official election tally.","title":"Cast Ballot"},{"location":"guide/Glossary/#ciphertext-ballot","text":"An encrypted representation of a voter's filled-in ballot.","title":"Ciphertext Ballot"},{"location":"guide/Glossary/#ciphertext-election-context","text":"The cryptographic context of an election that is configured during the Key Ceremony","title":"Ciphertext Election Context"},{"location":"guide/Glossary/#compensated-decryption-share","text":"A partial decryption share value computed by an available guardian to compensate for a missing guardian so that the missing guardian's share can be generated and the election results can be successfully decrypted.","title":"Compensated Decryption Share"},{"location":"guide/Glossary/#description-hash","text":"A hash representation of the original election description.","title":"Description Hash"},{"location":"guide/Glossary/#decryption-mediator","text":"A component or actor responsible for composing each guardian's partial decryptions or compensated decryptions into the plaintext tally","title":"Decryption Mediator"},{"location":"guide/Glossary/#decryption-share","text":"A guardian's partial share of a decryption","title":"Decryption Share"},{"location":"guide/Glossary/#election-description","text":"The election metadata that describes the structure and type of the election, including geopolitical units, contests, candidates, and ballot styles, etc.","title":"Election Description"},{"location":"guide/Glossary/#encryption-device","text":"The device that is doing the encryption","title":"Encryption Device"},{"location":"guide/Glossary/#election-key-pair","text":"Pair of keys (public & secret) used to encrypt/decrypt election","title":"Election Key Pair"},{"location":"guide/Glossary/#election-manifest","text":"The election metadata in json format that is parsed into an Election Description","title":"Election Manifest"},{"location":"guide/Glossary/#election-partial-key-backup","text":"A point on a secret polynomial and commitments to verify this point for a designated guardian.","title":"Election Partial Key Backup"},{"location":"guide/Glossary/#election-polynomial","text":"The election polynomial is the mathematical expression that each Guardian defines to solve for his or her private key. A different point associated with the polynomial is shared with each of the other guardians so that the guardians can come together to derive the polynomial function and solve for the private key.","title":"Election Polynomial"},{"location":"guide/Glossary/#encrypted-tally","text":"The homomorphically-combined and encrypted representation of all selections made for each option on every contest in the election.","title":"Encrypted Tally"},{"location":"guide/Glossary/#guardian","text":"A guardian of the election who holds the ability to partially decrypt the election results","title":"Guardian"},{"location":"guide/Glossary/#homomorphic-tally","text":"An encrypted representation of every selection on every ballot that was cast.","title":"Homomorphic Tally"},{"location":"guide/Glossary/#internal-election-description","text":"The subset of the election description required by ElectionGuard to validate ballots are correctly associated with an election. This component mutates the state of the Election Description.","title":"Internal Election Description"},{"location":"guide/Glossary/#joint-key","text":"Combined public key from election public keys of each guardian","title":"Joint Key"},{"location":"guide/Glossary/#key-ceremony","text":"The process conducted at the beginning of the election to create the joint encryption context for encrypting ballots during the election.","title":"Key Ceremony"},{"location":"guide/Glossary/#key-ceremony-mediator","text":"A mediator to mediate communication (if needed) of information such as keys between the guardians","title":"Key Ceremony Mediator"},{"location":"guide/Glossary/#missing-guardian","text":"A guardian who was configured during the Key Ceremony but who is not present for the decryption of the election results.","title":"Missing Guardian"},{"location":"guide/Glossary/#nonce","text":"A random number used to derive encryptions","title":"Nonce"},{"location":"guide/Glossary/#plaintext-ballot","text":"The plaintext representation of a voter's selections","title":"Plaintext Ballot"},{"location":"guide/Glossary/#quorum","text":"The minimum count ( threshold ) of guardians that must be present in order to successfully decrypt the election results.","title":"Quorum"},{"location":"guide/Glossary/#spoiled-ballot","text":"A ballot which a voter did not accept as valid and is not included in the tally.","title":"Spoiled Ballot"},{"location":"guide/Glossary/#tracking-code","text":"A unique hash value generated by an Encryption Device to anonymously identify a ballot","title":"Tracking Code"},{"location":"guide/Glossary/#unknown-ballot","text":"A ballot which may not yet be determined as cast or spoiled, or that may have been spoiled but is otherwise not published in the election results.","title":"Unknown Ballot"},{"location":"guide/Implementations/","text":"Reference Implementations These are reference implementations to showcase the scope of ElectionGuard. These repos can be seen as singular components or parts of the broader solution to fully verify an election. Web API A thin stateless API wrapping electionguard-python to perform ballot encryption, casting, spoiling, and tallying. Source | Docker | Documentation Archived Warning The following repositories are considered deprecated and are for research purposes not development. For active development, please look at non-archived section. Admin Device An application used to administer ElectionGuard election processes, including key generation, trustee provisioning, and post-election tallying, partial decryptions, and zero-knowledge proofs. Source Ballot Box Used to scan ballots to generate lists of cast and spoiled ballots in an election; used in tallying to finalize ballot operations (cast or spoil, etc.) for publishing results. Source Ballot Marking Device Working instance of ballot marking device (BMD). Built by VotingWorks in consultation with the Center for Civic Design , this front-end provides an interface for a voter to complete and print a ballot which, in an end-to-end verifiable use case, would be accompanied by a printed tracking ID. This BMD front-end is provided as one, potential implementation. Source Tracking Site An application that demonstrates publication of ElectionGuard election artifacts to a public website to enable verification ID lookup, downloadable zip files of the election result (for third-party verifiers), and election results summaries. Source Verifiers A verifier application is used to perform an external, independent verification of an election tally. This repository contains a reference implementation of a verifier built against the ElectionGuard specifications. This is not meant to be the only verifier application, but rather an example. This library should be used in tandem with the technical specifications and usage guidelines contained in the specifications . Source Community Verifiers Python Verifier by Rainbow Huang C# Verifier by Brandon Alexander Java Verifier by John Caron Python Verifier (electionguard-verify) by Nicholas Boucher","title":"Implementations"},{"location":"guide/Implementations/#reference-implementations","text":"These are reference implementations to showcase the scope of ElectionGuard. These repos can be seen as singular components or parts of the broader solution to fully verify an election.","title":"Reference Implementations"},{"location":"guide/Implementations/#web-api","text":"A thin stateless API wrapping electionguard-python to perform ballot encryption, casting, spoiling, and tallying. Source | Docker | Documentation","title":"Web API"},{"location":"guide/Implementations/#archived","text":"Warning The following repositories are considered deprecated and are for research purposes not development. For active development, please look at non-archived section.","title":"Archived"},{"location":"guide/Implementations/#admin-device","text":"An application used to administer ElectionGuard election processes, including key generation, trustee provisioning, and post-election tallying, partial decryptions, and zero-knowledge proofs. Source","title":"Admin Device"},{"location":"guide/Implementations/#ballot-box","text":"Used to scan ballots to generate lists of cast and spoiled ballots in an election; used in tallying to finalize ballot operations (cast or spoil, etc.) for publishing results. Source","title":"Ballot Box"},{"location":"guide/Implementations/#ballot-marking-device","text":"Working instance of ballot marking device (BMD). Built by VotingWorks in consultation with the Center for Civic Design , this front-end provides an interface for a voter to complete and print a ballot which, in an end-to-end verifiable use case, would be accompanied by a printed tracking ID. This BMD front-end is provided as one, potential implementation. Source","title":"Ballot Marking Device"},{"location":"guide/Implementations/#tracking-site","text":"An application that demonstrates publication of ElectionGuard election artifacts to a public website to enable verification ID lookup, downloadable zip files of the election result (for third-party verifiers), and election results summaries. Source","title":"Tracking Site"},{"location":"guide/Implementations/#verifiers","text":"A verifier application is used to perform an external, independent verification of an election tally. This repository contains a reference implementation of a verifier built against the ElectionGuard specifications. This is not meant to be the only verifier application, but rather an example. This library should be used in tandem with the technical specifications and usage guidelines contained in the specifications . Source","title":"Verifiers"},{"location":"guide/Implementations/#community-verifiers","text":"Python Verifier by Rainbow Huang C# Verifier by Brandon Alexander Java Verifier by John Caron Python Verifier (electionguard-verify) by Nicholas Boucher","title":"Community Verifiers"},{"location":"guide/Precinct_scan/","text":"ElectionGuard Precinct Scan Reference Implementation This is a work in progress. Comments are welcome on material already provided but assume it's known that sections are currently missing :) Overview By design, the ElectionGuard SDK can be used to enable end-to-end verifiability (e2e-v) in a variety of use cases. This article discusses the \"default\" use case of ElectionGuard: an end-to-end verifiable election that uses precinct scanners where ballots are inserted (and approved) by voters directly 1 . This document aims to provide a \" vertical slice \" of the considerations and practices necessary to add end-to-end verifiability to an existing precinct scanner. We necessarily make assumptions about the compute and storage capabilities of the scanner itself, and the modifications necessary to implement end-to-end verifiability . In so doing, it illustrates the interlocking system of security and encryption that comprises an e2e-v system . Generally, ElectionGuard relies on slight adaptations of existing voting processes to accommodate different aspects of e2e-v. For example, many voting jurisdictions already have a procedure called ballot spoiling to handle mistakes voters make when they fill out ballots. A voter may inadvertently fill out a contest incorrectly by selecting more candidates than allowed. When the voter then proceeds to scan the ballot, the scanner stops the ballot and alerts the voter of the overvote ; the voter then has the opportunity, as allowed within the voting regulations and practices of the voting district, to start over with a new ballot; the ballot with the mistake is then spoiled and stored separately to ensure it is not included in the tabulation. ElectionGuard uses this spoil process to enable a voter to test the integrity of the system capturing their vote. Effectively, the voter acts as if they are going to vote, submitting their ballot into the scanner and enabling it to process and interpret the ballot. After the encryption of the ballot has occurred, and the verification code has been generated, the voter can decide NOT to cast this ballot via some kind of option on the summary screen presented by the scanner. End-to-end verifiability mandates that these challenged ballots , unlike cast ballots , be published separately from the tally, and in addition that they be decrypted and published in their decrypted state. When voters use their verification code to look up the provenance of these challenged ballots after the election artifacts have been published, they will be able to see both that the ballot they challenged was NOT included in the tally, and also what its contents would have been if it were. When the contents of a challenged ballot are revealed to the voter and the selections match, their confidence about the provenance of their cast ballot is ideally bolstered. If the contents do not match their expectation, they should be given the means to flag this situation to election administrators to investigate. Thus, challenge ballots serve the dual role of affording voters the opportunity to more meaningfully evaluate the disposition of their voting preferences while also providing a security check on the voting system itself. Because the system has to be prepared for ANY voter to challenge a ballot, and because that challenge occurs AFTER the ElectionGuard encryption has occurred, the scanner has already committed its choice to ElectionGuard. And since the scanner can only encrypt ballots (only the tally process overseen by a quorum of election guardians has the \"power\" to decrypt anything ), the system is forced to act in good faith (if a small and random minority of voters can be relied upon to exercise challenges). This document illustrates these e2e-v concepts in the context of setting up and running an election. It begins with a general discussion of the precinct scan user experience and technical assumptions of scanner capabilities, and then runs an election, outlining where ElectionGuard needs to be integrated and ideally providing any wider security and integrity context for any process alterations that may obtain relative to current general election practice. Current Precinct Scan Voter Experience A typical voter flow for a precinct scan system is illustrated below. After a voter has acquired their ballot, they fill it out by hand or using a ballot marking device. When they finish they proceed to the scanner and insert the completed ballot. The scanner scans and interprets the ballot and generates a cast vote record , an electronic representation of the voter's selections. If all contests in a ballot are filled out properly and interpreted as such by the scanner, the ballot is accepted and the voter is free to leave the voting booth. If the scanner interprets the voter has voted for more options than the ballot contests allow (called an overvote ), the scanner stops the ballot from being deposited into the ballot box and prompts the voter whether they would like to have the ballot returned to fix the discrepancy. If the voter agrees, a poll worker is alerted and the ballot remediated by whatever process obtains, which could involve issuance of a new ballot and \"spoiling\" of the overvoted ballot. The scanner can also determine whether the voter didn't fill out all the contests available (called an undervote ). The scanner can be programmed to follow the same process as an overvote (returning the ballot for remediation), but election administrators often assume the undervote is intentional by the voter. Adapting Precinct Scan for End-to-end Verifiability (E2E-V) Voter Experience As outlined in the Verifiable Election page of the ElectionGuard SDK 2 , for end-to-end verifiability to apply, the precinct scanner itself must provide the following capabilities for each voter: immediately upon scanning the ballot, create an encrypted version of the ballot using the public key generated by the election guardians (see Key Ceremony) present the verification code generated by the encryption to the voter (ideally in paper format) present the means for the voter to cast or challenge (spoil) the ballot Technical Requirements For end-to-end verifiability, the scanner has to implement the user experience described above as well as generate and finalize an encrypted ballot reflecting the voter's selections. ElectionGuard assumes all other e2e-v functions such as key and tally ceremonies are performed independently of the scanner on modern laptop or desktop computers or secure cloud environments. Technical Implementation Overview and Operational Assumptions Precinct scanners, unlike other components of voting systems, are assumed to follow the economics and performance characteristics of embedded devices rather than consumer off-the-shelf (COTS) devices such as laptops. ElectionGuard assumes these devices operate in storage-limited environments more akin to operating systems such as Raspberry Pi than Windows 10. Information transfer (if not base storage) is assumed to occur via USB drives with capacities designed for space-efficient data constructs, not 4096-bit encryptions. To support operation in these environments, ElectionGuard enables an encryption-only library built in C++ from which it can target different standalone package deployments that generate encrypted ballots using a separately-provided public election key. Because encrypted ballots in modern elections can each occupy up to 1MB or more of device storage, ElectionGuard also specifies a dehydration \"process\" that allows a more space-efficient format for local storage and transmission post-election. Prior to initiating the tally and publishing process, these ballots are transferred to an external system and reconsitituted (and validated) by re-executing the encryption process using the dehydrated data as inputs. (See the discussions around ballot construction, chaining, etc., below to understand how dehydration should not affect system integrity or end-to-end verifiability.) General Election Setup Elections can be considered to have three core \"states\": the election itself, where voters cast their ballots, but also election setup and post-election data collection and tally publishing. ElectionGuard necessarily manifests in each state. Election setup generally consists of preparing the voting machines (we necessarily exclude all hand tabulations) for the current election contests, running any pre-production testing, and final configuration for election readiness. For ElectionGuard, the public election key generated by the election guardians is deployed to the scanner at this time and, if necessary, the ElectionGuard executable (we assume that the scanner is offline and code and election-related data is transferred via USB storage devices). Poll workers should also be prompted to manually enter an election launch code (see below) generated uniquely for the current election at election instantiation. In modern US elections, voters often vote multiple contests, determined by the type of election they're voting in and where they live. Because of the diversity of contests that different voters are eligible to vote in [even within a single county or precinct (imagine school districts, utility districts, city councillors, etc.)], a single precinct scanner may need to recognize and interpret tens or even hundreds of different ballot styles in a single election. Ballot manifest Consider a ballot manifest the master list of all the contests voters could face in a single election. ElectionGuard assumes and validates the ballot manifest for a variety of criteria . ElectionGuard uses manifests to properly interpret ballots generally, but for records created by precinct scanners the manifest provides the means to reconstitute the encrypted ballots from the dehydrated records created. Strictly speaking, the ballot manifest isn't necessary for ElectionGuard until the tally process evaluates the encrypted ballots generated during the election, but the precinct scanner needs to encode ballots and votes properly for their downstream construction, and that is dependent on the unique ballot styles presented to voters, which themselves need to follow proper convention as well. Public encryption key One of the core innovations of ElectionGuard is the use of multiple election guardians to administer the creation of election artifacts. Guardians are intended to be independent, trustworthy individuals. They don't need to have technical skills, but they do need to physically perform tasks collectively with the other guardians at the beginning and end of elections. As part of the election setup process, or any time prior, the guardians meet to create the public key that will be used by the precinct scanner to encrypt voter ballots. The Logic and Accuracy Testing Scanner Final Production Setup Launch Code Scanner Election Operation Ballot Encryption Generation of Verification Code Ballot Chaining Ballot Dehydration Dehydrated ballot structure A dehydrated ballot must provide the following data to be properly rehydrated and preserve end-to-end verifiability. Label Type Description Notes ballot_object_id string Unique ID to identify each ballot in an election session_id string Unique ID to enable the correct sorting of the election ballot chain when rehydrated needs to be resilient across device restarts and other service interruptions launch_code integer 10-digit ID generated at election initiation by rolling of 10-sided dice used to protect against attacks to insert votes outside of election context. See insert reference here ballot_style_id string Uniquely identifies the set of contests and responses a voter encounters with their ballot Used as part of the rehydration and tally processes to ensure the ballot is correctly interpreted and reconstituted ballot_finalization_indicator flag Indicates whether ballot is CAST or CHALLENGED applied by scanner based on determination by voter ballot_selections array Set of responses (and, as applicable, non-responses) of voter to ballot style reflective of non-selections; critical for rehydration and re-establishment of ballot encryption artifacts ballot_extra_data array Additional data applied at contest level to capture non-selection data Principally envisioned for capturing ballot selection metadata for write-ins; each entry needs to identify contest and selection as well as extra data string ballot_nonce ? The nonce used as input to the encryption of the ballot selections See spec on Ballot Encryption previous_tracker_hash ? As discussed in ballot chaining the previous_tracker_hash is an input to the current ballot encryption See spec on Ballot Encryption verification_code_hash ? Hashed version of verification code generated by ballot encryption process Ballot Finalization Cast ballots Challenge ballots As distinct from scanners used solely for central tabulation, which occurs with mail-in voting or any tabulation / aggregation scenario where voters are not present when the cast vote record is created \u21a9 ElectionGuard Verifiable Election [https://www.electionguard.vote/guide/Verifiable_Election/] \u21a9","title":"Precinct Scan Use Case"},{"location":"guide/Precinct_scan/#electionguard-precinct-scan-reference-implementation","text":"This is a work in progress. Comments are welcome on material already provided but assume it's known that sections are currently missing :)","title":"ElectionGuard Precinct Scan Reference Implementation"},{"location":"guide/Precinct_scan/#overview","text":"By design, the ElectionGuard SDK can be used to enable end-to-end verifiability (e2e-v) in a variety of use cases. This article discusses the \"default\" use case of ElectionGuard: an end-to-end verifiable election that uses precinct scanners where ballots are inserted (and approved) by voters directly 1 . This document aims to provide a \" vertical slice \" of the considerations and practices necessary to add end-to-end verifiability to an existing precinct scanner. We necessarily make assumptions about the compute and storage capabilities of the scanner itself, and the modifications necessary to implement end-to-end verifiability . In so doing, it illustrates the interlocking system of security and encryption that comprises an e2e-v system . Generally, ElectionGuard relies on slight adaptations of existing voting processes to accommodate different aspects of e2e-v. For example, many voting jurisdictions already have a procedure called ballot spoiling to handle mistakes voters make when they fill out ballots. A voter may inadvertently fill out a contest incorrectly by selecting more candidates than allowed. When the voter then proceeds to scan the ballot, the scanner stops the ballot and alerts the voter of the overvote ; the voter then has the opportunity, as allowed within the voting regulations and practices of the voting district, to start over with a new ballot; the ballot with the mistake is then spoiled and stored separately to ensure it is not included in the tabulation. ElectionGuard uses this spoil process to enable a voter to test the integrity of the system capturing their vote. Effectively, the voter acts as if they are going to vote, submitting their ballot into the scanner and enabling it to process and interpret the ballot. After the encryption of the ballot has occurred, and the verification code has been generated, the voter can decide NOT to cast this ballot via some kind of option on the summary screen presented by the scanner. End-to-end verifiability mandates that these challenged ballots , unlike cast ballots , be published separately from the tally, and in addition that they be decrypted and published in their decrypted state. When voters use their verification code to look up the provenance of these challenged ballots after the election artifacts have been published, they will be able to see both that the ballot they challenged was NOT included in the tally, and also what its contents would have been if it were. When the contents of a challenged ballot are revealed to the voter and the selections match, their confidence about the provenance of their cast ballot is ideally bolstered. If the contents do not match their expectation, they should be given the means to flag this situation to election administrators to investigate. Thus, challenge ballots serve the dual role of affording voters the opportunity to more meaningfully evaluate the disposition of their voting preferences while also providing a security check on the voting system itself. Because the system has to be prepared for ANY voter to challenge a ballot, and because that challenge occurs AFTER the ElectionGuard encryption has occurred, the scanner has already committed its choice to ElectionGuard. And since the scanner can only encrypt ballots (only the tally process overseen by a quorum of election guardians has the \"power\" to decrypt anything ), the system is forced to act in good faith (if a small and random minority of voters can be relied upon to exercise challenges). This document illustrates these e2e-v concepts in the context of setting up and running an election. It begins with a general discussion of the precinct scan user experience and technical assumptions of scanner capabilities, and then runs an election, outlining where ElectionGuard needs to be integrated and ideally providing any wider security and integrity context for any process alterations that may obtain relative to current general election practice.","title":"Overview"},{"location":"guide/Precinct_scan/#current-precinct-scan-voter-experience","text":"A typical voter flow for a precinct scan system is illustrated below. After a voter has acquired their ballot, they fill it out by hand or using a ballot marking device. When they finish they proceed to the scanner and insert the completed ballot. The scanner scans and interprets the ballot and generates a cast vote record , an electronic representation of the voter's selections. If all contests in a ballot are filled out properly and interpreted as such by the scanner, the ballot is accepted and the voter is free to leave the voting booth. If the scanner interprets the voter has voted for more options than the ballot contests allow (called an overvote ), the scanner stops the ballot from being deposited into the ballot box and prompts the voter whether they would like to have the ballot returned to fix the discrepancy. If the voter agrees, a poll worker is alerted and the ballot remediated by whatever process obtains, which could involve issuance of a new ballot and \"spoiling\" of the overvoted ballot. The scanner can also determine whether the voter didn't fill out all the contests available (called an undervote ). The scanner can be programmed to follow the same process as an overvote (returning the ballot for remediation), but election administrators often assume the undervote is intentional by the voter.","title":"Current Precinct Scan Voter Experience"},{"location":"guide/Precinct_scan/#adapting-precinct-scan-for-end-to-end-verifiability-e2e-v","text":"","title":"Adapting Precinct Scan for End-to-end Verifiability (E2E-V)"},{"location":"guide/Precinct_scan/#voter-experience","text":"As outlined in the Verifiable Election page of the ElectionGuard SDK 2 , for end-to-end verifiability to apply, the precinct scanner itself must provide the following capabilities for each voter: immediately upon scanning the ballot, create an encrypted version of the ballot using the public key generated by the election guardians (see Key Ceremony) present the verification code generated by the encryption to the voter (ideally in paper format) present the means for the voter to cast or challenge (spoil) the ballot","title":"Voter Experience"},{"location":"guide/Precinct_scan/#technical-requirements","text":"For end-to-end verifiability, the scanner has to implement the user experience described above as well as generate and finalize an encrypted ballot reflecting the voter's selections. ElectionGuard assumes all other e2e-v functions such as key and tally ceremonies are performed independently of the scanner on modern laptop or desktop computers or secure cloud environments.","title":"Technical Requirements"},{"location":"guide/Precinct_scan/#technical-implementation","text":"","title":"Technical Implementation"},{"location":"guide/Precinct_scan/#overview-and-operational-assumptions","text":"Precinct scanners, unlike other components of voting systems, are assumed to follow the economics and performance characteristics of embedded devices rather than consumer off-the-shelf (COTS) devices such as laptops. ElectionGuard assumes these devices operate in storage-limited environments more akin to operating systems such as Raspberry Pi than Windows 10. Information transfer (if not base storage) is assumed to occur via USB drives with capacities designed for space-efficient data constructs, not 4096-bit encryptions. To support operation in these environments, ElectionGuard enables an encryption-only library built in C++ from which it can target different standalone package deployments that generate encrypted ballots using a separately-provided public election key. Because encrypted ballots in modern elections can each occupy up to 1MB or more of device storage, ElectionGuard also specifies a dehydration \"process\" that allows a more space-efficient format for local storage and transmission post-election. Prior to initiating the tally and publishing process, these ballots are transferred to an external system and reconsitituted (and validated) by re-executing the encryption process using the dehydrated data as inputs. (See the discussions around ballot construction, chaining, etc., below to understand how dehydration should not affect system integrity or end-to-end verifiability.)","title":"Overview and Operational Assumptions"},{"location":"guide/Precinct_scan/#general-election-setup","text":"Elections can be considered to have three core \"states\": the election itself, where voters cast their ballots, but also election setup and post-election data collection and tally publishing. ElectionGuard necessarily manifests in each state. Election setup generally consists of preparing the voting machines (we necessarily exclude all hand tabulations) for the current election contests, running any pre-production testing, and final configuration for election readiness. For ElectionGuard, the public election key generated by the election guardians is deployed to the scanner at this time and, if necessary, the ElectionGuard executable (we assume that the scanner is offline and code and election-related data is transferred via USB storage devices). Poll workers should also be prompted to manually enter an election launch code (see below) generated uniquely for the current election at election instantiation. In modern US elections, voters often vote multiple contests, determined by the type of election they're voting in and where they live. Because of the diversity of contests that different voters are eligible to vote in [even within a single county or precinct (imagine school districts, utility districts, city councillors, etc.)], a single precinct scanner may need to recognize and interpret tens or even hundreds of different ballot styles in a single election.","title":"General Election Setup"},{"location":"guide/Precinct_scan/#ballot-manifest","text":"Consider a ballot manifest the master list of all the contests voters could face in a single election. ElectionGuard assumes and validates the ballot manifest for a variety of criteria . ElectionGuard uses manifests to properly interpret ballots generally, but for records created by precinct scanners the manifest provides the means to reconstitute the encrypted ballots from the dehydrated records created. Strictly speaking, the ballot manifest isn't necessary for ElectionGuard until the tally process evaluates the encrypted ballots generated during the election, but the precinct scanner needs to encode ballots and votes properly for their downstream construction, and that is dependent on the unique ballot styles presented to voters, which themselves need to follow proper convention as well.","title":"Ballot manifest"},{"location":"guide/Precinct_scan/#public-encryption-key","text":"One of the core innovations of ElectionGuard is the use of multiple election guardians to administer the creation of election artifacts. Guardians are intended to be independent, trustworthy individuals. They don't need to have technical skills, but they do need to physically perform tasks collectively with the other guardians at the beginning and end of elections. As part of the election setup process, or any time prior, the guardians meet to create the public key that will be used by the precinct scanner to encrypt voter ballots. The","title":"Public encryption key"},{"location":"guide/Precinct_scan/#logic-and-accuracy-testing","text":"","title":"Logic and Accuracy Testing"},{"location":"guide/Precinct_scan/#scanner-final-production-setup","text":"","title":"Scanner Final Production Setup"},{"location":"guide/Precinct_scan/#launch-code","text":"","title":"Launch Code"},{"location":"guide/Precinct_scan/#scanner-election-operation","text":"","title":"Scanner Election Operation"},{"location":"guide/Precinct_scan/#ballot-encryption","text":"","title":"Ballot Encryption"},{"location":"guide/Precinct_scan/#generation-of-verification-code","text":"","title":"Generation of Verification Code"},{"location":"guide/Precinct_scan/#ballot-chaining","text":"","title":"Ballot Chaining"},{"location":"guide/Precinct_scan/#ballot-dehydration","text":"","title":"Ballot Dehydration"},{"location":"guide/Precinct_scan/#dehydrated-ballot-structure","text":"A dehydrated ballot must provide the following data to be properly rehydrated and preserve end-to-end verifiability. Label Type Description Notes ballot_object_id string Unique ID to identify each ballot in an election session_id string Unique ID to enable the correct sorting of the election ballot chain when rehydrated needs to be resilient across device restarts and other service interruptions launch_code integer 10-digit ID generated at election initiation by rolling of 10-sided dice used to protect against attacks to insert votes outside of election context. See insert reference here ballot_style_id string Uniquely identifies the set of contests and responses a voter encounters with their ballot Used as part of the rehydration and tally processes to ensure the ballot is correctly interpreted and reconstituted ballot_finalization_indicator flag Indicates whether ballot is CAST or CHALLENGED applied by scanner based on determination by voter ballot_selections array Set of responses (and, as applicable, non-responses) of voter to ballot style reflective of non-selections; critical for rehydration and re-establishment of ballot encryption artifacts ballot_extra_data array Additional data applied at contest level to capture non-selection data Principally envisioned for capturing ballot selection metadata for write-ins; each entry needs to identify contest and selection as well as extra data string ballot_nonce ? The nonce used as input to the encryption of the ballot selections See spec on Ballot Encryption previous_tracker_hash ? As discussed in ballot chaining the previous_tracker_hash is an input to the current ballot encryption See spec on Ballot Encryption verification_code_hash ? Hashed version of verification code generated by ballot encryption process","title":"Dehydrated ballot structure"},{"location":"guide/Precinct_scan/#ballot-finalization","text":"","title":"Ballot Finalization"},{"location":"guide/Precinct_scan/#cast-ballots","text":"","title":"Cast ballots"},{"location":"guide/Precinct_scan/#challenge-ballots","text":"As distinct from scanners used solely for central tabulation, which occurs with mail-in voting or any tabulation / aggregation scenario where voters are not present when the cast vote record is created \u21a9 ElectionGuard Verifiable Election [https://www.electionguard.vote/guide/Verifiable_Election/] \u21a9","title":"Challenge ballots"},{"location":"guide/Sample_Data/","text":"Sample Data To better understand the data formats used by ElectionGuard, sample data is provided here to guide new developers. Three Sample Elections We have provided sample data for three different elections: Minimal - This is the most minimal election manifest file possible, designed to be easy to inspect and quick to develop against for rapid testing. All optional fields have been removed from the election manifest file. The election contains a single Yes/No referrendum with a single ballot style in a single geopolitical unit. Small - This is designed to be a relatively small and simple election, but with more complexity than the minimal election. This is a good sample data set to begin understanding more complex ballot types with two or more geopolitical units or ballot styles. Three contests are listed (one of each type: Yes/No Referrendum, Select One, and Select n of m), two GP units, two ballot styles, and a small number of recommended optional fields are included. Full - This is a more realistic ballot for a general election for a midsized municipality. This ballot contains many geopolitical units with multiple ballot styles and contains all optional metadata fields. This sample has multi-language support and multiple submitted ballot samples. Election Manifests The Election Manifest contains all the details of the election (such as contests, candidates, selections, ballot styles, etc.) and is required at the start of an ElectionGuard election. Manifest Examples: minimal | small | full Submitted Ballots Submitted Ballots are encrypted ballots that have been cast or spoiled. Cast ballots will be tallied and spoiled ballots are decrypted. Submitted Ballot Examples: minimal | small | full Artifacts Election Artifacts are the files required at the end of the election to verify the election and are intended to be posted publicly. There should not be any sensitive data (eg: no guardian private keys) in the artifacts. These include the following: Manifest Election Context Election Constants Encrypted Tally Decrypted Tally Guardian Records Encryption Device Information Encrypted Ballots Decrypted Spoiled Ballots Example Folder Structure: \ud83d\udcc2 artifacts --- \ud83d\udcc4 manifest.json --- \ud83d\udcc4 context.json --- \ud83d\udcc4 constants.json --- \ud83d\udcc4 encrypted_tally.json --- \ud83d\udcc4 tally.json --- \ud83d\udcc1 guardians --- \ud83d\udcc1 devices --- \ud83d\udcc1 encrypted_ballots --- \ud83d\udcc1 spoiled_ballots Artifacts Examples: minimal | small | full","title":"Sample Data"},{"location":"guide/Sample_Data/#sample-data","text":"To better understand the data formats used by ElectionGuard, sample data is provided here to guide new developers.","title":"Sample Data"},{"location":"guide/Sample_Data/#three-sample-elections","text":"We have provided sample data for three different elections: Minimal - This is the most minimal election manifest file possible, designed to be easy to inspect and quick to develop against for rapid testing. All optional fields have been removed from the election manifest file. The election contains a single Yes/No referrendum with a single ballot style in a single geopolitical unit. Small - This is designed to be a relatively small and simple election, but with more complexity than the minimal election. This is a good sample data set to begin understanding more complex ballot types with two or more geopolitical units or ballot styles. Three contests are listed (one of each type: Yes/No Referrendum, Select One, and Select n of m), two GP units, two ballot styles, and a small number of recommended optional fields are included. Full - This is a more realistic ballot for a general election for a midsized municipality. This ballot contains many geopolitical units with multiple ballot styles and contains all optional metadata fields. This sample has multi-language support and multiple submitted ballot samples.","title":"Three Sample Elections"},{"location":"guide/Sample_Data/#election-manifests","text":"The Election Manifest contains all the details of the election (such as contests, candidates, selections, ballot styles, etc.) and is required at the start of an ElectionGuard election. Manifest Examples: minimal | small | full","title":"Election Manifests"},{"location":"guide/Sample_Data/#submitted-ballots","text":"Submitted Ballots are encrypted ballots that have been cast or spoiled. Cast ballots will be tallied and spoiled ballots are decrypted. Submitted Ballot Examples: minimal | small | full","title":"Submitted Ballots"},{"location":"guide/Sample_Data/#artifacts","text":"Election Artifacts are the files required at the end of the election to verify the election and are intended to be posted publicly. There should not be any sensitive data (eg: no guardian private keys) in the artifacts. These include the following: Manifest Election Context Election Constants Encrypted Tally Decrypted Tally Guardian Records Encryption Device Information Encrypted Ballots Decrypted Spoiled Ballots Example Folder Structure: \ud83d\udcc2 artifacts --- \ud83d\udcc4 manifest.json --- \ud83d\udcc4 context.json --- \ud83d\udcc4 constants.json --- \ud83d\udcc4 encrypted_tally.json --- \ud83d\udcc4 tally.json --- \ud83d\udcc1 guardians --- \ud83d\udcc1 devices --- \ud83d\udcc1 encrypted_ballots --- \ud83d\udcc1 spoiled_ballots Artifacts Examples: minimal | small | full","title":"Artifacts"},{"location":"guide/Verifiable_Election/","text":"Creating a Verifiable Election ElectionGuard is a software development kit (SDK) election system vendors can use to implement end-to-end verifiable (E2E-V) elections. Because it is designed to be integrated into both existing and new systems, it needs to be flexible. However, for end-to-end verifiability to be achieved, the following 3 core capabilities must be delivered: The voter is given a verification code they can use to verify their ballot was included in the final tally The voter has the means to challenge a ballot The election results and all its encrypted artifacts, including zero knowledge proofs, are published to enable full independent verifiability by third parties We describe each of these capabilities in detail below. Voter Verification Code A voter verification code is generated by the ballot encryption process of ElectionGuard. It is generated when the user has submitted their ballot to the voting system. Generating the Verification Code Submitting a ballot can mean virtually pressing a \"Submit\" button on a touchscreen voting device, inserting a paper ballot into a digital scanner, or some other event that causes a cast vote record to be generated in the voting system. From a user experience standpoint, the ballot encryption occurs at a point after the voter has filled out all contests they plan to, and has had a chance to review all their choices in a summary screen (or the completed paper ballot). In the ballot marking device use case, the ballot would be encrypted after the voter presses submit. For a ballot scanner, the cast vote record is generated after the scanner has interpreted the ballot. Please note that while the diagrams above show devices such as 'encrypted ballot server', ElectionGuard is intended to be run in an offline environment ; as such, if an API or server is used to listen for or communicate encryption requests, they are expected to be run locally in a secure environment. Once the ballot has been encrypted, the encrypting device needs to handle the verification code returned by the ballot encryption process and present it to the voter, ideally by printing it at the moment of creation in a format easy for the voter to take with them. When the election results are published (see \"Publishing election results\" below), these verification codes are published alongside, enabling them to see that their ballots were included in the election tally (or, in the case of Challenge Ballots, that they were included as challenge ballots (see \"Challenging a Ballot\" below)) The verification code format is a mix of human-readable words and alphanumeric codes. The first word is always human-readable to facilitate a search-like discovery experience (to try, go to our demo tracking site and begin typing 'coo' to surface the verification code above, or simply click the image to be taken directly). Challenging a ballot Encrypting a ballot and generating a verification code is the first step in an E2E-V process for the voter. For E2E-V compliance, the voter has to be offered the ability to challenge or \"spoil\" the ballot after the verification code has been generated and provided to the voter. When a ballot is challenged, it is no longer eligible to be included in the final tally. If the voter wants to register a vote after a challenge, they will need to begin the process again with a new ballot. In addition, when a ballot is challenged, the system must be able to perform a decryption of the challenged ballot and reveal its contents to the voter. Challenging of ballots increases the inherent security of the system, since the system has to assume that any ballot encrypted might have to be revealed, exposing any manipulation that may have occurred after submission; the system can't assume its actions will remain hidden. Individual voters can obtain as much confidence as they desire by challenging as many ballots as they wish. Although they won't ever be shown that the encryption of a cast ballot matches their selections, voters can see that every challenged ballot was correctly encrypted and committed to before the decision to cast or challenge was made. The ability to observe that all challenge ballots are correct thereby provides indirect evidence that cast ballots were also correct. Publishing Verifiable results When the election is complete and the results tallied, E2E-V elections publish the results so they can be verified independently. E2E-V election verifiers are written by third parties according to their interpretation of the ElectionGuard Specification . Any data published by an election should enable each and every cast encrypted ballot to be interrogated and tallied independently. From the spec: An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). Two things must be proven about the encryption of each vote: The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in a contest is equal to the selection limit for that contest (usually one). ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. Chaum-Pedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013particularly that a value is an encryption of either zero or one. The set of encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit, again using a Chaum-Pedersen proof. Once every ballot is proven to be properly formed (as above), all of the votes for each option are homomorphically summed to produce encryptions of the tallies for each option. The final step is then to decrypt these tallies and provide additional proofs that the decryption are correct. Showing Verification Code Results to Voters In addition to satisfying the data requirements for proper verification, any publishing exercise needs to also enable individual voters to query for the ballot that matches their verification code. Verification code results of cast ballots will indicate that the ballot was included in the final tally, and any associated metadata about the device that recorded the ballot (time, location, election, etc.; see example above). Challenge ballots are also published. Results for verification codes of challenge ballots should indicate that the ballot was not included in the election tally. Because the ballot is not included in the election tally, the contents can be decrypted and presented as well.","title":"Verifiable Election"},{"location":"guide/Verifiable_Election/#creating-a-verifiable-election","text":"ElectionGuard is a software development kit (SDK) election system vendors can use to implement end-to-end verifiable (E2E-V) elections. Because it is designed to be integrated into both existing and new systems, it needs to be flexible. However, for end-to-end verifiability to be achieved, the following 3 core capabilities must be delivered: The voter is given a verification code they can use to verify their ballot was included in the final tally The voter has the means to challenge a ballot The election results and all its encrypted artifacts, including zero knowledge proofs, are published to enable full independent verifiability by third parties We describe each of these capabilities in detail below.","title":"Creating a Verifiable Election"},{"location":"guide/Verifiable_Election/#voter-verification-code","text":"A voter verification code is generated by the ballot encryption process of ElectionGuard. It is generated when the user has submitted their ballot to the voting system.","title":"Voter Verification Code"},{"location":"guide/Verifiable_Election/#generating-the-verification-code","text":"Submitting a ballot can mean virtually pressing a \"Submit\" button on a touchscreen voting device, inserting a paper ballot into a digital scanner, or some other event that causes a cast vote record to be generated in the voting system. From a user experience standpoint, the ballot encryption occurs at a point after the voter has filled out all contests they plan to, and has had a chance to review all their choices in a summary screen (or the completed paper ballot). In the ballot marking device use case, the ballot would be encrypted after the voter presses submit. For a ballot scanner, the cast vote record is generated after the scanner has interpreted the ballot. Please note that while the diagrams above show devices such as 'encrypted ballot server', ElectionGuard is intended to be run in an offline environment ; as such, if an API or server is used to listen for or communicate encryption requests, they are expected to be run locally in a secure environment. Once the ballot has been encrypted, the encrypting device needs to handle the verification code returned by the ballot encryption process and present it to the voter, ideally by printing it at the moment of creation in a format easy for the voter to take with them. When the election results are published (see \"Publishing election results\" below), these verification codes are published alongside, enabling them to see that their ballots were included in the election tally (or, in the case of Challenge Ballots, that they were included as challenge ballots (see \"Challenging a Ballot\" below)) The verification code format is a mix of human-readable words and alphanumeric codes. The first word is always human-readable to facilitate a search-like discovery experience (to try, go to our demo tracking site and begin typing 'coo' to surface the verification code above, or simply click the image to be taken directly).","title":"Generating the Verification Code"},{"location":"guide/Verifiable_Election/#challenging-a-ballot","text":"Encrypting a ballot and generating a verification code is the first step in an E2E-V process for the voter. For E2E-V compliance, the voter has to be offered the ability to challenge or \"spoil\" the ballot after the verification code has been generated and provided to the voter. When a ballot is challenged, it is no longer eligible to be included in the final tally. If the voter wants to register a vote after a challenge, they will need to begin the process again with a new ballot. In addition, when a ballot is challenged, the system must be able to perform a decryption of the challenged ballot and reveal its contents to the voter. Challenging of ballots increases the inherent security of the system, since the system has to assume that any ballot encrypted might have to be revealed, exposing any manipulation that may have occurred after submission; the system can't assume its actions will remain hidden. Individual voters can obtain as much confidence as they desire by challenging as many ballots as they wish. Although they won't ever be shown that the encryption of a cast ballot matches their selections, voters can see that every challenged ballot was correctly encrypted and committed to before the decision to cast or challenge was made. The ability to observe that all challenge ballots are correct thereby provides indirect evidence that cast ballots were also correct.","title":"Challenging a ballot"},{"location":"guide/Verifiable_Election/#publishing-verifiable-results","text":"When the election is complete and the results tallied, E2E-V elections publish the results so they can be verified independently. E2E-V election verifiers are written by third parties according to their interpretation of the ElectionGuard Specification . Any data published by an election should enable each and every cast encrypted ballot to be interrogated and tallied independently. From the spec: An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). Two things must be proven about the encryption of each vote: The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in a contest is equal to the selection limit for that contest (usually one). ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. Chaum-Pedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013particularly that a value is an encryption of either zero or one. The set of encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit, again using a Chaum-Pedersen proof. Once every ballot is proven to be properly formed (as above), all of the votes for each option are homomorphically summed to produce encryptions of the tallies for each option. The final step is then to decrypt these tallies and provide additional proofs that the decryption are correct.","title":"Publishing Verifiable results"},{"location":"guide/Verifiable_Election/#showing-verification-code-results-to-voters","text":"In addition to satisfying the data requirements for proper verification, any publishing exercise needs to also enable individual voters to query for the ballot that matches their verification code. Verification code results of cast ballots will indicate that the ballot was included in the final tally, and any associated metadata about the device that recorded the ballot (time, location, election, etc.; see example above). Challenge ballots are also published. Results for verification codes of challenge ballots should indicate that the ballot was not included in the election tally. Because the ballot is not included in the election tally, the contents can be decrypted and presented as well.","title":"Showing Verification Code Results to Voters"},{"location":"spec/Overview/","text":"Specification These documents contains the fundamental specifications, documentation, architecture, and mathematical/cryptographic proofs that underpin ElectionGuard. If you're looking to understand the system better, or want to know how to integrate the various components, there is a lot of valuable information contained here. v 1.0.0 Important This version is coming soon. Specification v 0.95.0 Specification | PDF v 0.85.0 Warning This version is deprecated. A new version is available. The basic process and concepts are still applicable. Specification","title":"Overview"},{"location":"spec/Overview/#specification","text":"These documents contains the fundamental specifications, documentation, architecture, and mathematical/cryptographic proofs that underpin ElectionGuard. If you're looking to understand the system better, or want to know how to integrate the various components, there is a lot of valuable information contained here.","title":"Specification"},{"location":"spec/Overview/#v-100","text":"Important This version is coming soon. Specification","title":"v 1.0.0"},{"location":"spec/Overview/#v-0950","text":"Specification | PDF","title":"v 0.95.0"},{"location":"spec/Overview/#v-0850","text":"Warning This version is deprecated. A new version is available. The basic process and concepts are still applicable. Specification","title":"v 0.85.0"},{"location":"spec/0.95.0/10_Applicability/","text":"Applicability to end-to-end verifiability and risk-limiting audits The methods described in this specification can be used to enable either end-to-end (E2E) verifiability or enhanced risk-limiting audits (RLAs). In both cases, the ballots are individually encrypted and proofs are provided to allow observers to verify that the set of encrypted ballots is consistent with the announced tallies in an election. In the case of E2E-verifiability, voters are given tracking codes to enable them to confirm that their individual ballots are correctly recorded amongst the set of encrypted ballots. In the case of RLAs, encrypted ballots are randomly selected and compared against physical ballots to obtain confidence that the physical records match the electronic records. To support enhanced risk-limiting audits (RLAs), it may be desirable to encrypt the master nonce of each ballot with a simple administrative key rather than the \u201cheavyweight\u201d election encryption key. This streamlines the process for decrypting an encrypted ballot that has been selected for audit. It should be noted that the privacy risks of revealing decrypted ballots are substantially reduced in the RLA case since voters are not given tracking codes that could be used to associate them with individual ballots. The primary risk is a coercion threat (e.g., via pattern voting) that only manifests if the full set of ballots were to be decrypted. While the administratively encrypted nonce can be stored in an electronic record alongside each encrypted ballot, one appealing RLA instantiation is for the administrative encryption of a ballot\u2019s nonce to be printed directly onto the physical ballot. This allows an RLA to proceed by randomly selecting an encrypted ballot, fetching the associated physical ballot, extracting the nonce from its encryption on the physical ballot, using the nonce to decrypt the electronic record, and then comparing the physical ballot contents with those of the electronic record. A malicious actor with an administrative decryption key would need to go to each individual physical ballot to obtain the nonces necessary to decrypt all of the encrypted ballots, and the access to do so would enable this malicious actor to obtain all of the open ballots without necessitating the administrative decryption key. If E2E-verifiability and enhanced RLAs are both provided in the same election, there must be separate ballot encryptions (ideally, but not necessary, using separate election encryption keys) of each ballot. The E2E-verifiable data set must be distinguished from the enhanced RLA data set. Using the same data set for both applications would compromise voter privacy for voters whose ballots are selected for auditing.","title":"Applicability to E2E Verifiability and RLA"},{"location":"spec/0.95.0/10_Applicability/#applicability-to-end-to-end-verifiability-and-risk-limiting-audits","text":"The methods described in this specification can be used to enable either end-to-end (E2E) verifiability or enhanced risk-limiting audits (RLAs). In both cases, the ballots are individually encrypted and proofs are provided to allow observers to verify that the set of encrypted ballots is consistent with the announced tallies in an election. In the case of E2E-verifiability, voters are given tracking codes to enable them to confirm that their individual ballots are correctly recorded amongst the set of encrypted ballots. In the case of RLAs, encrypted ballots are randomly selected and compared against physical ballots to obtain confidence that the physical records match the electronic records. To support enhanced risk-limiting audits (RLAs), it may be desirable to encrypt the master nonce of each ballot with a simple administrative key rather than the \u201cheavyweight\u201d election encryption key. This streamlines the process for decrypting an encrypted ballot that has been selected for audit. It should be noted that the privacy risks of revealing decrypted ballots are substantially reduced in the RLA case since voters are not given tracking codes that could be used to associate them with individual ballots. The primary risk is a coercion threat (e.g., via pattern voting) that only manifests if the full set of ballots were to be decrypted. While the administratively encrypted nonce can be stored in an electronic record alongside each encrypted ballot, one appealing RLA instantiation is for the administrative encryption of a ballot\u2019s nonce to be printed directly onto the physical ballot. This allows an RLA to proceed by randomly selecting an encrypted ballot, fetching the associated physical ballot, extracting the nonce from its encryption on the physical ballot, using the nonce to decrypt the electronic record, and then comparing the physical ballot contents with those of the electronic record. A malicious actor with an administrative decryption key would need to go to each individual physical ballot to obtain the nonces necessary to decrypt all of the encrypted ballots, and the access to do so would enable this malicious actor to obtain all of the open ballots without necessitating the administrative decryption key. If E2E-verifiability and enhanced RLAs are both provided in the same election, there must be separate ballot encryptions (ideally, but not necessary, using separate election encryption keys) of each ballot. The E2E-verifiable data set must be distinguished from the enhanced RLA data set. Using the same data set for both applications would compromise voter privacy for voters whose ballots are selected for auditing.","title":"Applicability to end-to-end verifiability and risk-limiting audits"},{"location":"spec/0.95.0/11_Acknowledgements/","text":"Acknowledgements The author is happy to thank Nicholas Boucher (@NickBoucher), Joey Dodds (@jdodds), Gerald Doussot, Aleks Essex, Rainbow Huang (@rainbowhuanguw), Chris Jeuell, Luke Myers, Dan Shumow, Vanessa Teague (@vteague), Aaron Tomb, Daniel Wagner, Jake Waksbaum, Matt Wilhelm (@AddressXception), and Greg Zaverucha for many helpful comments and suggestions on earlier versions of this specification.","title":"Acknowledgements"},{"location":"spec/0.95.0/11_Acknowledgements/#acknowledgements","text":"The author is happy to thank Nicholas Boucher (@NickBoucher), Joey Dodds (@jdodds), Gerald Doussot, Aleks Essex, Rainbow Huang (@rainbowhuanguw), Chris Jeuell, Luke Myers, Dan Shumow, Vanessa Teague (@vteague), Aaron Tomb, Daniel Wagner, Jake Waksbaum, Matt Wilhelm (@AddressXception), and Greg Zaverucha for many helpful comments and suggestions on earlier versions of this specification.","title":"Acknowledgements"},{"location":"spec/0.95.0/1_Overview/","text":"ElectionGuard Specification v0.95 Josh Benaloh (Microsoft Research) Overview This document describes the technical details of the ElectionGuard toolkit which can be used in conjunction with many new and existing voting systems to enable both end-to-end (E2E) verifiability and privacy-enhanced risk-limiting audits (RLAs). ElectionGuard is not a complete election system. It instead provides components that are designed to be flexible and to promote innovation by election officials and system developers. When properly used, it can promote voter confidence by empowering voters to independently verify the accuracy of election results. End-to-end (E2E) verifiability An E2E-verifiable election provides artifacts which allow voters to confirm that their votes have been accurately recorded and counted. Specifically, an election is End-to-end (E2E) verifiable if two properties are achieved. Individual voters can verify that their votes have been accurately recorded. Voters and observers can verify that the recorded votes have been accurately counted. An E2E-verifiable tally can be used as the primary tally in an election or as a verifiable secondary tally alongside traditional methods. ElectionGuard is compatible with in-person voting \u2013 either using an electronic ballot-marking device or an optical scanner capable of reading hand-marked or machine-marked ballots, with voting by mail, and even with Internet voting. Risk-limiting audits (RLAs) RLAs offer election administrators efficient methods to validate reported election tallies against physical ballot records. There are several varieties of RLAs, but the most efficient and practical are ballot-comparison audits in which electronic cast-vote records (CVRs) are individually compared against physical ballots. The challenge with ballot-comparison audits is that public release of the full set of CVRs can compromise voter privacy while an audit without public disclosure of CVRs offers no basis for public confidence in the outcome. ElectionGuard can bridge this gap by enabling public disclosure of encrypted ballots that can matched directly to physical ballots selected for auditing and can also be proven to match the reported tallies. About this specification This specification can be used by expert reviewers to evaluate the details of the ElectionGuard process and by independent parties to write ElectionGuard verifiers to confirm the consistency of election artifacts with announced election results. The details of the ElectionGuard Application Programming Interface (API) are provided in a separate document. ElectionGuard Structure In an election, a set of guardians is enlisted to serve as trustees who manage cryptographic keys. The members of a canvassing board can serve as guardians. Prior to the commencement of voting or auditing, the guardians work together to form a public encryption key that will be used to encrypt individual ballots. After the conclusion of voting or auditing, a quorum of guardians is necessary to produce the artifacts required to enable public verification of the tally. Key Generation Prior to the start of voting (for an E2E-verifiable election) or auditing (for an RLA), the election guardians participate in a process wherein they generate public keys to be used in the election. Each guardian generates an election key \u2013 for use in encrypting votes \u2013 and an auxiliary key \u2013 for use in encrypting other data. 1 Additional keys are generated to facilitate sharing of private keys so that the election verifiable data can be produced after voting or auditing is complete \u2013 even if not all guardians are available at that time. The key generation ceremony begins with each guardian publishing its public keys together with proofs of knowledge of the associated private keys. Once all of the public keys are published, each guardian uses each other guardian\u2019s public auxiliary key to encrypt shares of its own private keys. Finally, each guardian decrypts the shares it receives from other guardians and checks them for consistency. If the received shares verify, the receiving guardian announces its completion. If any shares fail to verify, the receiving guardian challenges the sender. In this case, the sender is obliged to reveal the shares it sent. If it does so and the shares verify, the ceremony concludes and the election proceeds. If a challenged guardian fails to produce key shares that verify, that guardian is removed and the key generation ceremony restarts with a replacement guardian. Ballot Encryption In most uses, the election system makes a single call to the ElectionGuard API after each voter completes the process of making selections or with each ballot to be encrypted for an RLA. ElectionGuard will encrypt the selections made by the voter and return a verification code which the system should give to the voter. 2 This is the only point where an existing election system must interface with ElectionGuard. In certain vote-by-mail scenarios and when ElectionGuard is used within an RLA, cast-vote records can be provided in batch without any interface between the voting equipment and ElectionGuard. There is no need to provide verification codes in the RLA scenario. The encrypted ballots are published along with non-interactive zero-knowledge proof of their integrity. The encrypted method used herein has a homomorphic property which allows the encrypted ballots to be combined into a single aggregate ballot which consists of encryptions of the election tallies. Verifiable Decryption In the final step, election guardians independently use their secret keys to decrypt the election tallies and associated verification data. It is not necessary for all guardians to be available to complete this step. If some guardians are missing, a quorum of guardians can use the previously shared key fragments to reconstruct the missing verification data. Observers can use this open specification and/or accompanying materials to write election verifiers that can confirm the integrity of each encrypted ballot, the correct aggregation of these ballots, and the accurate decryption of election tallies. The details of the ElectionGuard Application Programming Interface (API) are included in a separate document. The principal purposes of this document are to specify the functionality of the ElectionGuard toolkit and to provide details necessary for independent parties to write election verifiers that consume the artifacts produced by the toolkit. While the format of the election keys is critical to the process and carefully delineated in this document, the auxiliary keys are for internal use only and their format is left up to individual implementations. \u21a9 The verification code is not necessary for RLA usage. \u21a9","title":"Overview"},{"location":"spec/0.95.0/1_Overview/#electionguard-specification-v095","text":"Josh Benaloh (Microsoft Research)","title":"ElectionGuard Specification v0.95"},{"location":"spec/0.95.0/1_Overview/#overview","text":"This document describes the technical details of the ElectionGuard toolkit which can be used in conjunction with many new and existing voting systems to enable both end-to-end (E2E) verifiability and privacy-enhanced risk-limiting audits (RLAs). ElectionGuard is not a complete election system. It instead provides components that are designed to be flexible and to promote innovation by election officials and system developers. When properly used, it can promote voter confidence by empowering voters to independently verify the accuracy of election results.","title":"Overview"},{"location":"spec/0.95.0/1_Overview/#end-to-end-e2e-verifiability","text":"An E2E-verifiable election provides artifacts which allow voters to confirm that their votes have been accurately recorded and counted. Specifically, an election is End-to-end (E2E) verifiable if two properties are achieved. Individual voters can verify that their votes have been accurately recorded. Voters and observers can verify that the recorded votes have been accurately counted. An E2E-verifiable tally can be used as the primary tally in an election or as a verifiable secondary tally alongside traditional methods. ElectionGuard is compatible with in-person voting \u2013 either using an electronic ballot-marking device or an optical scanner capable of reading hand-marked or machine-marked ballots, with voting by mail, and even with Internet voting.","title":"End-to-end (E2E) verifiability"},{"location":"spec/0.95.0/1_Overview/#risk-limiting-audits-rlas","text":"RLAs offer election administrators efficient methods to validate reported election tallies against physical ballot records. There are several varieties of RLAs, but the most efficient and practical are ballot-comparison audits in which electronic cast-vote records (CVRs) are individually compared against physical ballots. The challenge with ballot-comparison audits is that public release of the full set of CVRs can compromise voter privacy while an audit without public disclosure of CVRs offers no basis for public confidence in the outcome. ElectionGuard can bridge this gap by enabling public disclosure of encrypted ballots that can matched directly to physical ballots selected for auditing and can also be proven to match the reported tallies.","title":"Risk-limiting audits (RLAs)"},{"location":"spec/0.95.0/1_Overview/#about-this-specification","text":"This specification can be used by expert reviewers to evaluate the details of the ElectionGuard process and by independent parties to write ElectionGuard verifiers to confirm the consistency of election artifacts with announced election results. The details of the ElectionGuard Application Programming Interface (API) are provided in a separate document.","title":"About this specification"},{"location":"spec/0.95.0/1_Overview/#electionguard-structure","text":"In an election, a set of guardians is enlisted to serve as trustees who manage cryptographic keys. The members of a canvassing board can serve as guardians. Prior to the commencement of voting or auditing, the guardians work together to form a public encryption key that will be used to encrypt individual ballots. After the conclusion of voting or auditing, a quorum of guardians is necessary to produce the artifacts required to enable public verification of the tally.","title":"ElectionGuard Structure"},{"location":"spec/0.95.0/1_Overview/#key-generation","text":"Prior to the start of voting (for an E2E-verifiable election) or auditing (for an RLA), the election guardians participate in a process wherein they generate public keys to be used in the election. Each guardian generates an election key \u2013 for use in encrypting votes \u2013 and an auxiliary key \u2013 for use in encrypting other data. 1 Additional keys are generated to facilitate sharing of private keys so that the election verifiable data can be produced after voting or auditing is complete \u2013 even if not all guardians are available at that time. The key generation ceremony begins with each guardian publishing its public keys together with proofs of knowledge of the associated private keys. Once all of the public keys are published, each guardian uses each other guardian\u2019s public auxiliary key to encrypt shares of its own private keys. Finally, each guardian decrypts the shares it receives from other guardians and checks them for consistency. If the received shares verify, the receiving guardian announces its completion. If any shares fail to verify, the receiving guardian challenges the sender. In this case, the sender is obliged to reveal the shares it sent. If it does so and the shares verify, the ceremony concludes and the election proceeds. If a challenged guardian fails to produce key shares that verify, that guardian is removed and the key generation ceremony restarts with a replacement guardian.","title":"Key Generation"},{"location":"spec/0.95.0/1_Overview/#ballot-encryption","text":"In most uses, the election system makes a single call to the ElectionGuard API after each voter completes the process of making selections or with each ballot to be encrypted for an RLA. ElectionGuard will encrypt the selections made by the voter and return a verification code which the system should give to the voter. 2 This is the only point where an existing election system must interface with ElectionGuard. In certain vote-by-mail scenarios and when ElectionGuard is used within an RLA, cast-vote records can be provided in batch without any interface between the voting equipment and ElectionGuard. There is no need to provide verification codes in the RLA scenario. The encrypted ballots are published along with non-interactive zero-knowledge proof of their integrity. The encrypted method used herein has a homomorphic property which allows the encrypted ballots to be combined into a single aggregate ballot which consists of encryptions of the election tallies.","title":"Ballot Encryption"},{"location":"spec/0.95.0/1_Overview/#verifiable-decryption","text":"In the final step, election guardians independently use their secret keys to decrypt the election tallies and associated verification data. It is not necessary for all guardians to be available to complete this step. If some guardians are missing, a quorum of guardians can use the previously shared key fragments to reconstruct the missing verification data. Observers can use this open specification and/or accompanying materials to write election verifiers that can confirm the integrity of each encrypted ballot, the correct aggregation of these ballots, and the accurate decryption of election tallies. The details of the ElectionGuard Application Programming Interface (API) are included in a separate document. The principal purposes of this document are to specify the functionality of the ElectionGuard toolkit and to provide details necessary for independent parties to write election verifiers that consume the artifacts produced by the toolkit. While the format of the election keys is critical to the process and carefully delineated in this document, the auxiliary keys are for internal use only and their format is left up to individual implementations. \u21a9 The verification code is not necessary for RLA usage. \u21a9","title":"Verifiable Decryption"},{"location":"spec/0.95.0/2_Structure/","text":"ElectionGuard Structure Overview In an election, a set of guardians is enlisted to serve as trustees who manage cryptographic keys. The members of a canvassing board can serve as guardians. Prior to the commencement of voting or auditing, the guardians work together to form a public encryption key that will be used to encrypt individual ballots. After the conclusion of voting or auditing, a quorum of guardians is necessary to produce the artifacts required to enable public verification of the tally. ElectionGuard has four principal components: Baseline Parameters \u2013 These are general parameters that are standard in every election. An alternate means for generating parameters is described, but the burden of verifying an election is increased if alternate parameters are used because a verifier would need to verify the proper construction of any alternate parameters. Key Generation \u2013 Prior to each individual election, guardians must generate individual public-private key pairs and exchange shares of private keys to enable completion of an election even if some guardians become unavailable. Although it is preferred to generate new keys for each election, it is permissible to use the same keys for multiple elections so long as the set of guardians remains the same. A complete new set of keys must be generated if even a single guardian is replaced. Ballot Encryption \u2013 While encrypting the contents of a ballot is a relatively simple operation, most of the work of ElectionGuard is the process of creating externally verifiable artifacts to prove that each encrypted ballot is well-formed (i.e., its decryption is a legitimate ballot without overvotes or improper values). Verifiable Decryption \u2013 At the conclusion of each election, guardians use their private keys to produce election tallies together with verifiable artifacts that prove that the tallies are correct. Notation In the remainder of this specification, the following notation will be used: \\(\u2124 = \\{\\dots , \u22123, \u22122, \u22121, 0, 1, 2, 3, \\dots\\}\\) is the set of integers. \\(\u2124_\\eta = \\{0, 1, 2, \\dots , n \u2212 1\\}\\) is the additive group of the integers modulo \\(p\\) . \\(Z_\\eta^*\\) is the multiplicative subgroup of \\(Z_\\eta\\) . When \\(p\\) is a prime, \\(Z_p^* = \\{1,2,3, \\dots, p-1\\}\\) . \\(Z_p^r\\) is the set of \\(r^{th}\\) -residues in \\(Z_p^*\\) . Formally, \\(Z_p^r = \\{ y \\in Z_p^*\\) for which \\(\\exists x \\in Z_p^*\\) such that \\(y=x^r\\bmod p \\}\\) . When \\(p\\) is a prime for which \\(p-1=qr\\) with \\(q\\) a prime that is not a divisor of integer \\(r\\) , then \\(Z_r^p\\) is an order \\(q\\) cyclic subgroup of \\(Z_p^*\\) and for each \\(y\\in Z_p^*\\) , \\(y\\in Z_r^p\\) if and only if \\(y^q \\bmod p = 1\\) . \\(x\\equiv_n y\\) is the predicate that is true if and only if \\(x \\bmod n = y \\bmod n\\) . The function \\(H()\\) shall be use to designate the SHA-256 hash function (as defined in NIST PUB FIPS 180-4 1 ). In general, the variable pairs \\((\\alpha, \\beta)\\) , \\((a, b)\\) , and \\((A,B)\\) will be used to denote encryptions. Specifically, \\((\\alpha,\\beta)\\) will be used to designate encryptions of votes ( always an encryption of a zero or one), \\((A,B)\\) will be used to denote aggregations of encryptions (which may be encryptions of larger values), and \\((a,b)\\) will be used to denote encryption commitments used to prove properties of other encryptions. Encryption of Votes Encryption of votes in ElectionGuard is performed using an exponential form of the ElGamal cryptosystem 2 . Primes \\(p\\) and \\(q\\) are publicly fixed such that \\(q\\) is not a divisor of \\(r=\\frac{p-1}{q}\\) . A generator \\(g\\) of the order \\(q\\) subgroup \\(Z_r^p\\) is also fixed. (Any \\(g=x^r\\bmod p\\) for which \\(x \\in Z_p^*\\) suffices so long as \\(g\\ne 1\\) ). A public-private key pair can be chosen by selecting a random \\(s \\in Z_q\\) as a private key and publishing \\(K = g^s \\bmod p\\) as a public key. 3 A message \\(M \\in Z_p^r\\) is then encrypted by selecting a random nonce \\(R \\in Z_q\\) and forming the pair \\((\\alpha,\\beta) = (g^R \\bmod p, g^M \\dot K^R \\bmod p)\\) . An encryption \\((\\alpha,\\beta)\\) can be decrypted by the holder of the secret \\(s\\) as \\[ \\frac{\\beta}{\\alpha^s}\\bmod p= \\frac{g^M \\cdot K^R}{(g^R)^s}\\bmod p = \\frac{g^M \\cdot (g^s)^R}{(g^R)^s} \\bmod p = \\frac{g^M \\cdot g^{Rs}}{g^{Rs}} \\bmod p = g^M \\bmod p \\] The value of \\(M\\) can be computed from \\(g^M \\bmod p\\) as long as the message \\(M\\) is limited to a small, known set of options. Only two possible messages are encrypted in this way by ElectionGuard: an encryption of one is used to indicate that an option is selected, and an encryption of zero is used to indicate that an option is not selected. Homomorphic Properties A fundamental quality of the exponential form of ElGamal described earlier is its additively homomorphic property. If two messages \\(M_1\\) and \\(M_2\\) are respectively encrypted as \\((A_1,B_1) = (g^{R_1} \\bmod p,g^{M_1}\\cdot K^{R_1} \\bmod p)\\) and \\((A_2,B_2) = (g^{R_2} \\bmod p,g^{M_2}\\cdot K^{R_2} \\bmod p)\\) then the component-wise product \\((A,B) = (A_1 A_2 \\bmod p, B_1 B_2 \\bmod p = (g^{R_1 + R_2} \\bmod p, g^{M_1 + M_2} \\cdot K^{R_1 + R_2} \\bmod p)\\) is an encryption of the sum \\(M_1 + M_2\\) . (There is an implicit assumption here that \\(M_1 + M_2 < q\\) which is easily satisfied when \\(M_1\\) and \\(M_2\\) are both small. If \\((R_1 + R_2) \\ge q, (R_1 + R_2) \\bmod q\\) may be substituted without changing the equation since \\(g^q \\bmod p =1\\) .) This additively homomorphic property is used in two important ways in ElectionGuard. First, all of the encryptions of a single option across ballots can be multiplied to form an encryption of the sum of the individual values. Since the individual values are one on ballots that select that option and zero otherwise, the sum is the tally of votes for that option and the product of the individual encryptions is an encryption of the tally. The other use is to sum all of the selections made in a single contest on a single ballot. After demonstrating that each option is an encryption of either zero or one, the product of the encryptions indicates the number of options that are encryptions of one, and this can be used to show that no more ones than permitted are among the encrypted options \u2013 i.e., that no more options were selected than permitted. However, as will be described below, it is possible for a holder of a nonce \ud835\udc45 to prove to a third party that a pair (\ud835\udefc, \ud835\udefd) is an encryption of \ud835\udc40 without revealing the nonce \ud835\udc45 and without access to the secret \ud835\udc60. Non-Interactive Zero-Knowledge (NIZK) Proofs ElectionGuard provides numerous proofs about encryption keys, encrypted ballots, and election tallies using the following four techniques. A Schnorr proof 5 allows the holder of an ElGamal secret key \ud835\udc60 to interactively prove possession of \\(s\\) without revealing \\(s\\) . A Chaum-Pedersen proof 6 allows an ElGamal encryption to be interactively proven to decrypt to a particular value without revealing the nonce used for encryption or the secret decryption key \\(s\\) . (This proof can be constructed with access to either the nonce used for encryption or the secret decryption key.) The Cramer-Damg\u00e5rd-Schoenmakers technique 7 enables a disjunction to be interactively proven without revealing which disjunct is true. The Fiat-Shamir heuristic 8 allows interactive proofs to be converted into non- interactive proofs. Using a combination of the above techniques, it is possible for ElectionGuard to demonstrate that keys are properly chosen, that ballots are properly formed, and that decryptions match claimed values. Threshold Encryption Threshold ElGamal encryption is used for encryption of ballots and other data. This form of encryption makes it very easy to combine individual guardian public keys into a single public key. It also offers a homomorphic property that allows individual encrypted votes to be combined to form encrypted tallies. The guardians of an election will each generate a public-private key pair. The public keys will then be combined (as described in the following section) into a single election public key which is used to encrypt all selections made by voters in the election. Ideally, at the conclusion of the election, each guardian will use its private key to form a verifiable partial decryption of each tally. These partial decryptions will then be combined to form full verifiable decryptions of the election tallies. To accommodate the possibility that one or more of the guardians will not be available at the conclusion of the election to form their partial decryptions, the guardians will cryptographically share their private keys amongst each other during key generation in a manner to be detailed in the next section. A pre-determined threshold quorum value \\((k)\\) out of the \\((n)\\) guardians will be necessary to produce a full decryption. NIST (2015) Secure Hash Standard (SHS). In: FIPS 180-4. https://csrc.nist.gov/publications/detail/fips/180/4/final \u21a9 ElGamal T. (1985) A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms. In: Blakley G.R., Chaum D. (eds) Advances in Cryptology. CRYPTO 1984. Lecture Notes in Computer Science, vol 196 https://link.springer.com/content/pdf/10.1007/3-540-39568-7_2.pdf \u21a9 As will be seen below, the actual public key used to encrypt votes will be a combination of separately-generated public keys. So no entity will ever be in possession of a private key that can be used to decrypt votes. \u21a9 The simplest way to compute \\(M\\) from \\(g^M \\bmod p\\) is an exhaustive search through possible values of \\(M\\) . Alternatively, a table of pairing each possible value of \\(g^M \\bmod p\\) can be pre-computed. A final option which can accommodate a larger space of possible values for \\(M\\) is to use Shanks\u2019s baby-step giant-step method as described in the 1971 paper \u201cClass Number, a Theory of Factorization and Genera,\u201d Proceedings of Symposium in Pure Mathematics, Vol. 20, American Mathematical Society, Providence, 1971, pp. 415-440. \u21a9 Schnorr C.P. (1990) Efficient Identification and Signatures for Smart Cards. In: Brassard G. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 89 Proceedings. CRYPTO 1989. Lecture Notes in Computer Science, vol 435. Springer, New York, NY. https://link.springer.com/content/pdf/10.1007/0-387-34805-0_22.pdf \u21a9 Chaum D., Pedersen T.P. (1993) Wallet Databases with Observers. In: Brickell E.F. (eds) Advances in Cryptology \u2014 CRYPTO' 92. Lecture Notes in Computer Science, volume 740. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007/3-540-48071-4_7.pdf \u21a9 Fiat A., Shamir A. (1987) How To Prove Yourself: Practical Solutions to Identification and Signature Problems. In: Odlyzko A.M. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 86. CRYPTO 1986. Lecture Notes in Computer Science, vol 263. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3-540-47721-7_12.pdf \u21a9 Fiat A., Shamir A. (1987) How To Prove Yourself: Practical Solutions to Identification and Signature Problems. In: Odlyzko A.M. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 86. CRYPTO 1986. Lecture Notes in Computer Science, vol 263. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3-540-47721-7_12.pdf \u21a9 Shamir A. How to Share a Secret. (1979) Communications of the ACM \u21a9","title":"Structure"},{"location":"spec/0.95.0/2_Structure/#electionguard-structure","text":"","title":"ElectionGuard Structure"},{"location":"spec/0.95.0/2_Structure/#overview","text":"In an election, a set of guardians is enlisted to serve as trustees who manage cryptographic keys. The members of a canvassing board can serve as guardians. Prior to the commencement of voting or auditing, the guardians work together to form a public encryption key that will be used to encrypt individual ballots. After the conclusion of voting or auditing, a quorum of guardians is necessary to produce the artifacts required to enable public verification of the tally. ElectionGuard has four principal components: Baseline Parameters \u2013 These are general parameters that are standard in every election. An alternate means for generating parameters is described, but the burden of verifying an election is increased if alternate parameters are used because a verifier would need to verify the proper construction of any alternate parameters. Key Generation \u2013 Prior to each individual election, guardians must generate individual public-private key pairs and exchange shares of private keys to enable completion of an election even if some guardians become unavailable. Although it is preferred to generate new keys for each election, it is permissible to use the same keys for multiple elections so long as the set of guardians remains the same. A complete new set of keys must be generated if even a single guardian is replaced. Ballot Encryption \u2013 While encrypting the contents of a ballot is a relatively simple operation, most of the work of ElectionGuard is the process of creating externally verifiable artifacts to prove that each encrypted ballot is well-formed (i.e., its decryption is a legitimate ballot without overvotes or improper values). Verifiable Decryption \u2013 At the conclusion of each election, guardians use their private keys to produce election tallies together with verifiable artifacts that prove that the tallies are correct.","title":"Overview"},{"location":"spec/0.95.0/2_Structure/#notation","text":"In the remainder of this specification, the following notation will be used: \\(\u2124 = \\{\\dots , \u22123, \u22122, \u22121, 0, 1, 2, 3, \\dots\\}\\) is the set of integers. \\(\u2124_\\eta = \\{0, 1, 2, \\dots , n \u2212 1\\}\\) is the additive group of the integers modulo \\(p\\) . \\(Z_\\eta^*\\) is the multiplicative subgroup of \\(Z_\\eta\\) . When \\(p\\) is a prime, \\(Z_p^* = \\{1,2,3, \\dots, p-1\\}\\) . \\(Z_p^r\\) is the set of \\(r^{th}\\) -residues in \\(Z_p^*\\) . Formally, \\(Z_p^r = \\{ y \\in Z_p^*\\) for which \\(\\exists x \\in Z_p^*\\) such that \\(y=x^r\\bmod p \\}\\) . When \\(p\\) is a prime for which \\(p-1=qr\\) with \\(q\\) a prime that is not a divisor of integer \\(r\\) , then \\(Z_r^p\\) is an order \\(q\\) cyclic subgroup of \\(Z_p^*\\) and for each \\(y\\in Z_p^*\\) , \\(y\\in Z_r^p\\) if and only if \\(y^q \\bmod p = 1\\) . \\(x\\equiv_n y\\) is the predicate that is true if and only if \\(x \\bmod n = y \\bmod n\\) . The function \\(H()\\) shall be use to designate the SHA-256 hash function (as defined in NIST PUB FIPS 180-4 1 ). In general, the variable pairs \\((\\alpha, \\beta)\\) , \\((a, b)\\) , and \\((A,B)\\) will be used to denote encryptions. Specifically, \\((\\alpha,\\beta)\\) will be used to designate encryptions of votes ( always an encryption of a zero or one), \\((A,B)\\) will be used to denote aggregations of encryptions (which may be encryptions of larger values), and \\((a,b)\\) will be used to denote encryption commitments used to prove properties of other encryptions.","title":"Notation"},{"location":"spec/0.95.0/2_Structure/#encryption-of-votes","text":"Encryption of votes in ElectionGuard is performed using an exponential form of the ElGamal cryptosystem 2 . Primes \\(p\\) and \\(q\\) are publicly fixed such that \\(q\\) is not a divisor of \\(r=\\frac{p-1}{q}\\) . A generator \\(g\\) of the order \\(q\\) subgroup \\(Z_r^p\\) is also fixed. (Any \\(g=x^r\\bmod p\\) for which \\(x \\in Z_p^*\\) suffices so long as \\(g\\ne 1\\) ). A public-private key pair can be chosen by selecting a random \\(s \\in Z_q\\) as a private key and publishing \\(K = g^s \\bmod p\\) as a public key. 3 A message \\(M \\in Z_p^r\\) is then encrypted by selecting a random nonce \\(R \\in Z_q\\) and forming the pair \\((\\alpha,\\beta) = (g^R \\bmod p, g^M \\dot K^R \\bmod p)\\) . An encryption \\((\\alpha,\\beta)\\) can be decrypted by the holder of the secret \\(s\\) as \\[ \\frac{\\beta}{\\alpha^s}\\bmod p= \\frac{g^M \\cdot K^R}{(g^R)^s}\\bmod p = \\frac{g^M \\cdot (g^s)^R}{(g^R)^s} \\bmod p = \\frac{g^M \\cdot g^{Rs}}{g^{Rs}} \\bmod p = g^M \\bmod p \\] The value of \\(M\\) can be computed from \\(g^M \\bmod p\\) as long as the message \\(M\\) is limited to a small, known set of options. Only two possible messages are encrypted in this way by ElectionGuard: an encryption of one is used to indicate that an option is selected, and an encryption of zero is used to indicate that an option is not selected.","title":"Encryption of Votes"},{"location":"spec/0.95.0/2_Structure/#homomorphic-properties","text":"A fundamental quality of the exponential form of ElGamal described earlier is its additively homomorphic property. If two messages \\(M_1\\) and \\(M_2\\) are respectively encrypted as \\((A_1,B_1) = (g^{R_1} \\bmod p,g^{M_1}\\cdot K^{R_1} \\bmod p)\\) and \\((A_2,B_2) = (g^{R_2} \\bmod p,g^{M_2}\\cdot K^{R_2} \\bmod p)\\) then the component-wise product \\((A,B) = (A_1 A_2 \\bmod p, B_1 B_2 \\bmod p = (g^{R_1 + R_2} \\bmod p, g^{M_1 + M_2} \\cdot K^{R_1 + R_2} \\bmod p)\\) is an encryption of the sum \\(M_1 + M_2\\) . (There is an implicit assumption here that \\(M_1 + M_2 < q\\) which is easily satisfied when \\(M_1\\) and \\(M_2\\) are both small. If \\((R_1 + R_2) \\ge q, (R_1 + R_2) \\bmod q\\) may be substituted without changing the equation since \\(g^q \\bmod p =1\\) .) This additively homomorphic property is used in two important ways in ElectionGuard. First, all of the encryptions of a single option across ballots can be multiplied to form an encryption of the sum of the individual values. Since the individual values are one on ballots that select that option and zero otherwise, the sum is the tally of votes for that option and the product of the individual encryptions is an encryption of the tally. The other use is to sum all of the selections made in a single contest on a single ballot. After demonstrating that each option is an encryption of either zero or one, the product of the encryptions indicates the number of options that are encryptions of one, and this can be used to show that no more ones than permitted are among the encrypted options \u2013 i.e., that no more options were selected than permitted. However, as will be described below, it is possible for a holder of a nonce \ud835\udc45 to prove to a third party that a pair (\ud835\udefc, \ud835\udefd) is an encryption of \ud835\udc40 without revealing the nonce \ud835\udc45 and without access to the secret \ud835\udc60.","title":"Homomorphic Properties"},{"location":"spec/0.95.0/2_Structure/#non-interactive-zero-knowledge-nizk-proofs","text":"ElectionGuard provides numerous proofs about encryption keys, encrypted ballots, and election tallies using the following four techniques. A Schnorr proof 5 allows the holder of an ElGamal secret key \ud835\udc60 to interactively prove possession of \\(s\\) without revealing \\(s\\) . A Chaum-Pedersen proof 6 allows an ElGamal encryption to be interactively proven to decrypt to a particular value without revealing the nonce used for encryption or the secret decryption key \\(s\\) . (This proof can be constructed with access to either the nonce used for encryption or the secret decryption key.) The Cramer-Damg\u00e5rd-Schoenmakers technique 7 enables a disjunction to be interactively proven without revealing which disjunct is true. The Fiat-Shamir heuristic 8 allows interactive proofs to be converted into non- interactive proofs. Using a combination of the above techniques, it is possible for ElectionGuard to demonstrate that keys are properly chosen, that ballots are properly formed, and that decryptions match claimed values.","title":"Non-Interactive Zero-Knowledge (NIZK) Proofs"},{"location":"spec/0.95.0/2_Structure/#threshold-encryption","text":"Threshold ElGamal encryption is used for encryption of ballots and other data. This form of encryption makes it very easy to combine individual guardian public keys into a single public key. It also offers a homomorphic property that allows individual encrypted votes to be combined to form encrypted tallies. The guardians of an election will each generate a public-private key pair. The public keys will then be combined (as described in the following section) into a single election public key which is used to encrypt all selections made by voters in the election. Ideally, at the conclusion of the election, each guardian will use its private key to form a verifiable partial decryption of each tally. These partial decryptions will then be combined to form full verifiable decryptions of the election tallies. To accommodate the possibility that one or more of the guardians will not be available at the conclusion of the election to form their partial decryptions, the guardians will cryptographically share their private keys amongst each other during key generation in a manner to be detailed in the next section. A pre-determined threshold quorum value \\((k)\\) out of the \\((n)\\) guardians will be necessary to produce a full decryption. NIST (2015) Secure Hash Standard (SHS). In: FIPS 180-4. https://csrc.nist.gov/publications/detail/fips/180/4/final \u21a9 ElGamal T. (1985) A Public Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms. In: Blakley G.R., Chaum D. (eds) Advances in Cryptology. CRYPTO 1984. Lecture Notes in Computer Science, vol 196 https://link.springer.com/content/pdf/10.1007/3-540-39568-7_2.pdf \u21a9 As will be seen below, the actual public key used to encrypt votes will be a combination of separately-generated public keys. So no entity will ever be in possession of a private key that can be used to decrypt votes. \u21a9 The simplest way to compute \\(M\\) from \\(g^M \\bmod p\\) is an exhaustive search through possible values of \\(M\\) . Alternatively, a table of pairing each possible value of \\(g^M \\bmod p\\) can be pre-computed. A final option which can accommodate a larger space of possible values for \\(M\\) is to use Shanks\u2019s baby-step giant-step method as described in the 1971 paper \u201cClass Number, a Theory of Factorization and Genera,\u201d Proceedings of Symposium in Pure Mathematics, Vol. 20, American Mathematical Society, Providence, 1971, pp. 415-440. \u21a9 Schnorr C.P. (1990) Efficient Identification and Signatures for Smart Cards. In: Brassard G. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 89 Proceedings. CRYPTO 1989. Lecture Notes in Computer Science, vol 435. Springer, New York, NY. https://link.springer.com/content/pdf/10.1007/0-387-34805-0_22.pdf \u21a9 Chaum D., Pedersen T.P. (1993) Wallet Databases with Observers. In: Brickell E.F. (eds) Advances in Cryptology \u2014 CRYPTO' 92. Lecture Notes in Computer Science, volume 740. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007/3-540-48071-4_7.pdf \u21a9 Fiat A., Shamir A. (1987) How To Prove Yourself: Practical Solutions to Identification and Signature Problems. In: Odlyzko A.M. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 86. CRYPTO 1986. Lecture Notes in Computer Science, vol 263. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3-540-47721-7_12.pdf \u21a9 Fiat A., Shamir A. (1987) How To Prove Yourself: Practical Solutions to Identification and Signature Problems. In: Odlyzko A.M. (eds) Advances in Cryptology \u2014 CRYPTO\u2019 86. CRYPTO 1986. Lecture Notes in Computer Science, vol 263. Springer, Berlin, Heidelberg. https://link.springer.com/content/pdf/10.1007%2F3-540-47721-7_12.pdf \u21a9 Shamir A. How to Share a Secret. (1979) Communications of the ACM \u21a9","title":"Threshold Encryption"},{"location":"spec/0.95.0/3_Baseline_parameters/","text":"Baseline Election Parameters ElectionGuard uses integer ElGamal rather than elliptic-curve ElGamal in order to make construction of election verifiers as simple as possible without requiring special tools and dependencies. The exponential ElGamal used to encrypt votes is defined by a 4096-bit prime \\(p\\) and a 256-bit prime \\(q\\) which divides \\((p \u2212 1)\\) . We use \\(r=\\frac{p-1}{q}\\) to denote the cofactor of \\(q\\) , and a generator \\(g\\) of the order \\(q\\) subgroup \\(Z_p^r\\) is fixed. Another parameter of an election should be a public ballot coding file. This file should list all the contests in an election, the number of selections allowed for each contest, and the options for each contest together with associations between each option and its representation on a virtual ballot. It is assumed that each contest in the ballot coding file has a unique label and that within each contest, each option also has a unique label. For instance, if Alice, Bob, and Carol are running for governor, and David and Ellen are running for senator, the ballot coding file could enable the vector \\(\\langle0,1,0; 0,1\\rangle\\) to be recognized as a ballot with votes for Bob as governor and Ellen as senator. The detailed format of a ballot coding file will not be specified in this document. But the contents of this file are hashed together with the prime modulus \\((p)\\) , subgroup order \\((q)\\) , generator \\((g)\\) , number of guardians \\((n)\\) , decryption quorum threshold value \\((k)\\) , date, and jurisdictional information to form a base hash code \\((Q)\\) which will be incorporated into every subsequent hash computation in the election. Standard parameters for ElectionGuard begin with the largest 256-bit prime \\(q = 2256 \u2212 189\\) . The hexadecimal representation of \\(q\\) is as follows. FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFF43 The modulus \\(p\\) is then set to be a 4096-bit prime with the following properties: The first 256 bits of \\(p\\) are all ones The last 256 bits of \\(p\\) are all ones \\(p-1\\) is a multiple of \\(q\\) \\(\\frac{p-1}{2q}\\) is also prime The middle 3,584 bits of \\(p\\) are chosen by starting with the first 3,584 bits of the Euler-Mascheroni constant \\((\\gamma)\\) , pre-pending and appending 256 ones, and finding the smallest prime larger than this number that satisfies the above properties. This works out to \\(p=2^{4096}-2^{3840} - 1 + 2^{256}(\\lfloor2^{3584}\\gamma\\rfloor + \\delta)\\) where the value of \\(\\delta = 495448529856135475846147600290107731951815687842437876083937612367400355133042233301\\) 1 The hexadecimal representation of \\(q\\) is as follows: FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 93C467E3 7DB0C7A4 D1BE3F81 0152CB56 A1CECC3A F65CC019 0C03DF34 709AFFBD 8E4B59FA 03A9F0EE D0649CCB 621057D1 1056AE91 32135A08 E43B4673 D74BAFEA 58DEB878 CC86D733 DBE7BF38 154B36CF 8A96D156 7899AAAE 0C09D4C8 B6B7B86F D2A1EA1D E62FF864 3EC7C271 82797722 5E6AC2F0 BD61C746 961542A3 CE3BEA5D B54FE70E 63E6D09F 8FC28658 E80567A4 7CFDE60E E741E5D8 5A7BD469 31CED822 03655949 64B83989 6FCAABCC C9B31959 C083F22A D3EE591C 32FAB2C7 448F2A05 7DB2DB49 EE52E018 2741E538 65F004CC 8E704B7C 5C40BF30 4C4D8C4F 13EDF604 7C555302 D2238D8C E11DF242 4F1B66C2 C5D238D0 744DB679 AF289048 7031F9C0 AEA1C4BB 6FE9554E E528FDF1 B05E5B25 6223B2F0 9215F371 9F9C7CCC 69DDF172 D0D62342 17FCC003 7F18B93E F5389130 B7A661E5 C26E5421 4068BBCA FEA32A67 818BD307 5AD1F5C7 E9CC3D17 37FB2817 1BAF84DB B6612B78 81C1A48E 439CD03A 92BF5222 5A2B38E6 542E9F72 2BCE15A3 81B5753E A8427633 81CCAE83 512B3051 1B32E5E8 D8036214 9AD030AA BA5F3A57 98BB22AA 7EC1B6D0 F17903F4 E234EA60 34AA8597 3F79A93F FB82A75C 47C03D43 D2F9CA02 D03199BA CEDDD453 34DBC6B5 FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF The hexadecimal representation of the cofactor \\(r=p-1\\) is as follows: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 000000BC 93C467E3 7DB0C7A4 D1BE3F81 0152CB56 A1CECC3A F65CC019 0C03DF34 709B8AF6 A64C0CED CF2D559D A9D97F09 5C3076C6 86037619 148D2C86 C317102A FA214803 1F04440A C0FF0C9A 417A8921 2512E760 7B2501DA A4D38A2C 1410C483 6149E2BD B8C8260E 627C4646 963EFFE9 E16E495D 48BD215C 6D8EC9D1 667657A2 A1C8506F 2113FFAD 19A6B2BC 7C457604 56719183 309F874B C9ACE570 FFDA877A A2B23A2D 6F291C15 54CA2EB1 2F12CD00 9B8B8734 A64AD51E B893BD89 1750B851 62241D90 8F0C9709 879758E7 E8233EAB 3BF2D6AB 53AFA32A A153AD66 82E5A064 8897C9BE 18A0D50B ECE030C3 432336AD 9163E33F 8E7DAF49 8F14BB28 52AFFA81 4841EB18 DD5F0E89 516D5577 76285C16 071D2111 94EE1C3F 34642036 AB886E3E C28882CE 4003DEA3 35B4D935 BAE4B582 35B9FB2B AB713C8F 705A1C7D E4222020 9D6BBCAC C4673186 01565272 E4A63E38 E2499754 AE493AC1 A8E83469 EEF35CA2 7C271BC7 92EEE211 56E617B9 22EA8F71 3C22CF28 2DC5D638 5BB12868 EB781278 FA0AB2A8 958FCCB5 FFE2E5C3 61FC1744 20122B01 63CA4A46 308C8C46 C91EA745 7C1AD0D6 9FD4A7F5 29FD4A7F 529FD4A7 F529FD4A 7F529FD4 A7F529FD 4A7F529F D4A7F52A Finally, the generator \\(g\\) is chosen to be \\(g=2r \\bmod p\\) and has the following hexadecimal representation 037DE384 F98F6E03 8D2A3141 825B33D5 D45EC4CC 64CFD15E 750D6798 F5196CF2 A142CDF3 3F6EF853 840EC7D4 EC804794 CFB0CFB6 5363B256 6387B98E E0E3DEF1 B706FA55 D5038FFB 4A62DCBB 93B1DDD8 D3B308DA 86D1C3A5 25EF356F E5BB5931 4E656334 80B396E1 DD4B795F 78DE07D8 6B0E2A05 BE6AF78F D7F736FC BA6C032E 26E050AF 50A03C65 FA7B6C87 F4554CB5 7F3DABCB AD8EB9D8 FDEBEEF5 8570669A CC3EDA17 DBFC47B8 B3C39AA0 8B829B28 872E62B5 D1B13A98 F09D40AC 20C2AB74 A6750E7C 8750B514 1E221C41 F55BBA31 D8E41422 B64D2CBA 7AAA0E9F D8785702 F6932825 BF45DE83 86D24900 742062C1 322B37C5 0AF18215 8090C35D A9355E6C F7F72DA3 9A2284FD FB1918B2 A2A30E69 501FA234 2B728263 DF23F1DB 8355BDE1 EB276FB3 685F3716 72CEB313 FDAB069C C9B11AB6 C59BCE62 BAAD96AA C96B0DBE 0C7E71FC B2255254 5A5D1CED EEE01E4B C0CDBDB7 6B6AD45F 09AF5E71 114A005F 93AD97B8 FE09274E 76C94B20 08926B38 CAEC94C9 5E96D628 F6BC8066 2BA06207 801328B2 C6A60526 BF7CD02D 9661385A C3B1CBDB 50F759D0 E9F61C11 A07BF421 8F299BCB 29005200 76EBD2D9 5A3DEE96 D4809EF3 4ABEB83F DBA8A12C 5CA82757 288A89C9 31CF564F 00E8A317 AE1E1D82 8E61369B A0DDBADB 10C136F8 691101AD 82DC5477 5AB83538 40D99921 97D80A6E 94B38AC4 17CDDF40 B0C73ABF 03E8E0AA Info Alternative parameter sets are possible. A good source for parameter generation is appendix A of FIPS 186-4 2 . However, allowing alternate parameters would force election verifiers to recognize and check that parameters are correctly generated. Since these checks would be very different from other checks that are required of a verifier, allowing alternate parameters would add substantial complexity to election verifiers. For this reason, this version of ElectionGuard fixes the parameters as above. Important An ElectionGuard version 1 election verifier may assume that the baseline parameters match the parameters provided above. However, it is recommended that the above parameters be checked against the parameters of each election to accommodate the possibility of different parameters in future versions of ElectionGuard 3 . Discovering this value \\(\\delta\\) required a search through roughly 42 million values satisfying the first three of the above properties to find one for which both \\(p\\) and \\(\\frac{(p-1)}{2q}\\) are both prime. \u21a9 NIST (2013) Digital Signature Standard (DSS). In: FIPS 186-4. https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf \u21a9 If alternative parameters are allowed, election verifiers must confirm that \\(p\\) , \\(q,\\) \\(r\\) , and \\(g\\) are such that both \\(p\\) and \\(q\\) are prime (this may be done probabilistically using the Miller-Rabin algorithm), that \\(p-1=qr\\) is satisfied, that \\(q\\) is not a divisor of \\(r\\) , that \\(1 \\lt g \\lt p\\) , that \\(g^q \\bmod p=1\\) , and that generation of the parameters is consistent with the cited standard. \u21a9","title":"Baseline Parameters"},{"location":"spec/0.95.0/3_Baseline_parameters/#baseline-election-parameters","text":"ElectionGuard uses integer ElGamal rather than elliptic-curve ElGamal in order to make construction of election verifiers as simple as possible without requiring special tools and dependencies. The exponential ElGamal used to encrypt votes is defined by a 4096-bit prime \\(p\\) and a 256-bit prime \\(q\\) which divides \\((p \u2212 1)\\) . We use \\(r=\\frac{p-1}{q}\\) to denote the cofactor of \\(q\\) , and a generator \\(g\\) of the order \\(q\\) subgroup \\(Z_p^r\\) is fixed. Another parameter of an election should be a public ballot coding file. This file should list all the contests in an election, the number of selections allowed for each contest, and the options for each contest together with associations between each option and its representation on a virtual ballot. It is assumed that each contest in the ballot coding file has a unique label and that within each contest, each option also has a unique label. For instance, if Alice, Bob, and Carol are running for governor, and David and Ellen are running for senator, the ballot coding file could enable the vector \\(\\langle0,1,0; 0,1\\rangle\\) to be recognized as a ballot with votes for Bob as governor and Ellen as senator. The detailed format of a ballot coding file will not be specified in this document. But the contents of this file are hashed together with the prime modulus \\((p)\\) , subgroup order \\((q)\\) , generator \\((g)\\) , number of guardians \\((n)\\) , decryption quorum threshold value \\((k)\\) , date, and jurisdictional information to form a base hash code \\((Q)\\) which will be incorporated into every subsequent hash computation in the election. Standard parameters for ElectionGuard begin with the largest 256-bit prime \\(q = 2256 \u2212 189\\) . The hexadecimal representation of \\(q\\) is as follows. FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFF43 The modulus \\(p\\) is then set to be a 4096-bit prime with the following properties: The first 256 bits of \\(p\\) are all ones The last 256 bits of \\(p\\) are all ones \\(p-1\\) is a multiple of \\(q\\) \\(\\frac{p-1}{2q}\\) is also prime The middle 3,584 bits of \\(p\\) are chosen by starting with the first 3,584 bits of the Euler-Mascheroni constant \\((\\gamma)\\) , pre-pending and appending 256 ones, and finding the smallest prime larger than this number that satisfies the above properties. This works out to \\(p=2^{4096}-2^{3840} - 1 + 2^{256}(\\lfloor2^{3584}\\gamma\\rfloor + \\delta)\\) where the value of \\(\\delta = 495448529856135475846147600290107731951815687842437876083937612367400355133042233301\\) 1 The hexadecimal representation of \\(q\\) is as follows: FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF 93C467E3 7DB0C7A4 D1BE3F81 0152CB56 A1CECC3A F65CC019 0C03DF34 709AFFBD 8E4B59FA 03A9F0EE D0649CCB 621057D1 1056AE91 32135A08 E43B4673 D74BAFEA 58DEB878 CC86D733 DBE7BF38 154B36CF 8A96D156 7899AAAE 0C09D4C8 B6B7B86F D2A1EA1D E62FF864 3EC7C271 82797722 5E6AC2F0 BD61C746 961542A3 CE3BEA5D B54FE70E 63E6D09F 8FC28658 E80567A4 7CFDE60E E741E5D8 5A7BD469 31CED822 03655949 64B83989 6FCAABCC C9B31959 C083F22A D3EE591C 32FAB2C7 448F2A05 7DB2DB49 EE52E018 2741E538 65F004CC 8E704B7C 5C40BF30 4C4D8C4F 13EDF604 7C555302 D2238D8C E11DF242 4F1B66C2 C5D238D0 744DB679 AF289048 7031F9C0 AEA1C4BB 6FE9554E E528FDF1 B05E5B25 6223B2F0 9215F371 9F9C7CCC 69DDF172 D0D62342 17FCC003 7F18B93E F5389130 B7A661E5 C26E5421 4068BBCA FEA32A67 818BD307 5AD1F5C7 E9CC3D17 37FB2817 1BAF84DB B6612B78 81C1A48E 439CD03A 92BF5222 5A2B38E6 542E9F72 2BCE15A3 81B5753E A8427633 81CCAE83 512B3051 1B32E5E8 D8036214 9AD030AA BA5F3A57 98BB22AA 7EC1B6D0 F17903F4 E234EA60 34AA8597 3F79A93F FB82A75C 47C03D43 D2F9CA02 D03199BA CEDDD453 34DBC6B5 FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF The hexadecimal representation of the cofactor \\(r=p-1\\) is as follows: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 000000BC 93C467E3 7DB0C7A4 D1BE3F81 0152CB56 A1CECC3A F65CC019 0C03DF34 709B8AF6 A64C0CED CF2D559D A9D97F09 5C3076C6 86037619 148D2C86 C317102A FA214803 1F04440A C0FF0C9A 417A8921 2512E760 7B2501DA A4D38A2C 1410C483 6149E2BD B8C8260E 627C4646 963EFFE9 E16E495D 48BD215C 6D8EC9D1 667657A2 A1C8506F 2113FFAD 19A6B2BC 7C457604 56719183 309F874B C9ACE570 FFDA877A A2B23A2D 6F291C15 54CA2EB1 2F12CD00 9B8B8734 A64AD51E B893BD89 1750B851 62241D90 8F0C9709 879758E7 E8233EAB 3BF2D6AB 53AFA32A A153AD66 82E5A064 8897C9BE 18A0D50B ECE030C3 432336AD 9163E33F 8E7DAF49 8F14BB28 52AFFA81 4841EB18 DD5F0E89 516D5577 76285C16 071D2111 94EE1C3F 34642036 AB886E3E C28882CE 4003DEA3 35B4D935 BAE4B582 35B9FB2B AB713C8F 705A1C7D E4222020 9D6BBCAC C4673186 01565272 E4A63E38 E2499754 AE493AC1 A8E83469 EEF35CA2 7C271BC7 92EEE211 56E617B9 22EA8F71 3C22CF28 2DC5D638 5BB12868 EB781278 FA0AB2A8 958FCCB5 FFE2E5C3 61FC1744 20122B01 63CA4A46 308C8C46 C91EA745 7C1AD0D6 9FD4A7F5 29FD4A7F 529FD4A7 F529FD4A 7F529FD4 A7F529FD 4A7F529F D4A7F52A Finally, the generator \\(g\\) is chosen to be \\(g=2r \\bmod p\\) and has the following hexadecimal representation 037DE384 F98F6E03 8D2A3141 825B33D5 D45EC4CC 64CFD15E 750D6798 F5196CF2 A142CDF3 3F6EF853 840EC7D4 EC804794 CFB0CFB6 5363B256 6387B98E E0E3DEF1 B706FA55 D5038FFB 4A62DCBB 93B1DDD8 D3B308DA 86D1C3A5 25EF356F E5BB5931 4E656334 80B396E1 DD4B795F 78DE07D8 6B0E2A05 BE6AF78F D7F736FC BA6C032E 26E050AF 50A03C65 FA7B6C87 F4554CB5 7F3DABCB AD8EB9D8 FDEBEEF5 8570669A CC3EDA17 DBFC47B8 B3C39AA0 8B829B28 872E62B5 D1B13A98 F09D40AC 20C2AB74 A6750E7C 8750B514 1E221C41 F55BBA31 D8E41422 B64D2CBA 7AAA0E9F D8785702 F6932825 BF45DE83 86D24900 742062C1 322B37C5 0AF18215 8090C35D A9355E6C F7F72DA3 9A2284FD FB1918B2 A2A30E69 501FA234 2B728263 DF23F1DB 8355BDE1 EB276FB3 685F3716 72CEB313 FDAB069C C9B11AB6 C59BCE62 BAAD96AA C96B0DBE 0C7E71FC B2255254 5A5D1CED EEE01E4B C0CDBDB7 6B6AD45F 09AF5E71 114A005F 93AD97B8 FE09274E 76C94B20 08926B38 CAEC94C9 5E96D628 F6BC8066 2BA06207 801328B2 C6A60526 BF7CD02D 9661385A C3B1CBDB 50F759D0 E9F61C11 A07BF421 8F299BCB 29005200 76EBD2D9 5A3DEE96 D4809EF3 4ABEB83F DBA8A12C 5CA82757 288A89C9 31CF564F 00E8A317 AE1E1D82 8E61369B A0DDBADB 10C136F8 691101AD 82DC5477 5AB83538 40D99921 97D80A6E 94B38AC4 17CDDF40 B0C73ABF 03E8E0AA Info Alternative parameter sets are possible. A good source for parameter generation is appendix A of FIPS 186-4 2 . However, allowing alternate parameters would force election verifiers to recognize and check that parameters are correctly generated. Since these checks would be very different from other checks that are required of a verifier, allowing alternate parameters would add substantial complexity to election verifiers. For this reason, this version of ElectionGuard fixes the parameters as above. Important An ElectionGuard version 1 election verifier may assume that the baseline parameters match the parameters provided above. However, it is recommended that the above parameters be checked against the parameters of each election to accommodate the possibility of different parameters in future versions of ElectionGuard 3 . Discovering this value \\(\\delta\\) required a search through roughly 42 million values satisfying the first three of the above properties to find one for which both \\(p\\) and \\(\\frac{(p-1)}{2q}\\) are both prime. \u21a9 NIST (2013) Digital Signature Standard (DSS). In: FIPS 186-4. https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf \u21a9 If alternative parameters are allowed, election verifiers must confirm that \\(p\\) , \\(q,\\) \\(r\\) , and \\(g\\) are such that both \\(p\\) and \\(q\\) are prime (this may be done probabilistically using the Miller-Rabin algorithm), that \\(p-1=qr\\) is satisfied, that \\(q\\) is not a divisor of \\(r\\) , that \\(1 \\lt g \\lt p\\) , that \\(g^q \\bmod p=1\\) , and that generation of the parameters is consistent with the cited standard. \u21a9","title":"Baseline Election Parameters"},{"location":"spec/0.95.0/4_Key_generation/","text":"Key Generation Before an election, the number of guardians \\((n)\\) is fixed together with a quorum value \\((k)\\) that describes the number of guardians necessary to decrypt tallies and produce election verification data. The values \\(n\\) and \\(k\\) are integers subject to the constraint that \\(1 \\le k \\le n\\) . Canvassing board members can often serve the role of election guardians, and typical values for \\(n\\) and \\(k\\) could be 5 and 3 \u2013 indicating that 3 of 5 canvassing board members must cooperate to produce the artifacts that enable election verification. The reason for not setting the quorum value \\(k\\) too low is that it will also be possible for \\(k\\) guardians to decrypt individual ballots. Info Note that decryption of individual ballots does not directly compromise voter privacy since links between encrypted ballots and the voters who cast them are not retained by the system. However, voters receive verification codes that can be associated with individual encrypted ballots, so any group that has the ability to decrypt individual ballots can also coerce voters by demanding to see their tracking codes. Threshold ElGamal encryption is used for encryption of ballots. This form of encryption makes it very easy to combine individual guardian public keys into a single public key for encrypting votes and ballots. It also offers a homomorphic property that allows individual encrypted votes to be combined to form encrypted tallies. The guardians of an election will each generate a public-private key pair. The public keys will then be combined (as described in the following section) into a single election public key which is used to encrypt all selections made by voters in the election. Ideally, at the conclusion of the election, each guardian will use its private key to form a verifiable partial decryption of each tally. These partial decryptions will then be combined to form full verifiable decryptions of the election tallies. To accommodate the possibility that one or more of the guardians will not be available at the conclusion of the election to form their partial decryptions, the guardians will cryptographically share 1 their private keys amongst each other during key generation in a manner to be detailed in the next section. A pre-determined threshold value \\((k)\\) out of the \\((n)\\) guardians will be necessary to produce a full decryption. Additionally, each guardian will also generate an auxiliary public-private key pair. These auxiliary keys will be used by the guardians to exchange fragments of their principal vote- encryption keys and for other scenarios in which non-vote data may need to be encrypted. Overview of Key Generation The \\(n\\) guardians of an election are denoted by \\(T_1,T_2,\\ldots, T_n\\) . Each guardian \\(T_i\\) generates an independent ElGamal public-private key pair by generating a random integer secret \\(s_i \\in Z_q\\) and forming the public key \\(K_i=g^{s_i}\\bmod p\\) . Each of these public keys will be published in the election record together with a non-interactive zero-knowledge Schnorr proof of knowledge of possession of the associated private key. The joint election public key will be \\[ K = \\prod_{i=1}^n K_i \\bmod p \\] To enable robustness and allow for the possibility of missing guardians at the conclusion of an election, the ElectionGuard key generation includes a sharing of private keys between guardians to enable decryption by any \\(k\\) guardians. This sharing is verifiable, so that receiving guardians can confirm that the shares they receive are meaningful; and the process allows for decryption without explicitly reconstructing private keys of missing guardians. Each guardian \\(T\\) generates \\(k-1\\) random polynomial coefficients \\(a_{i,j}\\) such that \\(0\\lt j \\lt k\\) and \\(0 \\le a_{i,j} \\le q\\) and forms the polynomial \\[ P_i(x) = \\sum_{j=0}^{k-1}a_{i,j}x^j\\bmod q \\] by setting \\(a_{i,0}\\) equal to its secret value \\(s_i\\) . Guardian \\(T_i\\) then publishes commitments \\(K_{i,j}= g^{a_{i,j}} \\bmod p\\) to each of its random polynomial coefficients. As with the primary secret keys, each guardian should provide a Schnorr proof of knowledge of the secret coefficient value \\(a_{i,j}\\) associated with each published commitment \\(K_{i,j}\\) . Since polynomial coefficients will be generated and managed in precisely the same fashion as secret keys, they will be treated together in a single step below. At the conclusion of the election, individual encrypted ballots will be homomorphically combined into a single encrypted aggregate ballot \u2013 consisting of an encryption of the tally for each option offered to voters. Each guardian will use its secret key to generate a partial decryption of each encrypted tally value, and these partial decryptions will be combined into full decryptions. If any election guardians are missing during tallying, any set of \\(k\\) guardians who are available can cooperate to reconstruct the missing partial decryption. All spoiled ballots are individually decrypted in precisely the same fashion. Details of Key Generation Each guardian \\(T\\) in an election with a decryption threshold of \\(k\\) generates \\(k\\) secret polynomial \\(i\\) coefficients \\(a_{i,j}\\) such that \\(0\\le j \\le k\\) and \\(0 \\le a_{i,j} \\lt q\\) and forms the polynomial \\[ P_i(x) = \\sum_{j=0}^{k-1} a_{i,j}x^j \\bmod q \\] Guardian \\(T_i\\) then publishes commitments \\(K_{i,j} = g^{a_{i,j}} \\bmod q\\) for each of its random polynomial coefficients. The constant term \\(a_{i,0}\\) of this polynomial will serve as the private key for guardian \\(T_i\\) and will also be denoted as \\(K_i = K_{i,0}\\) . In order to prove possession of the coefficient associated with each public commitment, for each \\(K_{i,j}\\) with \\(0 \\le j \\lt k\\) , guardian \\(T_i\\) generates a Schnorr proof of knowledge for each of its coefficients. This Non-Interactive Zero-Knowledge (NIZK) proof proceeds as follows. NIZK Shnorr proof by Guardian of knowledge for each of its coefficients Formally: NIZK Proof by Guardian \\(T_i\\) of its knowledge of secrets \\(a_{i,j}\\) such that \\(K_{i,j}= g^{a_{i,j}} \\bmod p\\) For each \\(0 \\le j \\lt k\\) , Guardian \\(T_i\\) generates random integer values \\(R_{i,j}\\) in \\(Z_q\\) and computes \\(h_{i,j}=g^{R_{i,j}} \\bmod p\\) . Then, using the hash function SHA-256 (as defined in NIST PUB FIPS 180-4 2 ), guardian \\(T_i\\) then performs a single hash computation \\(c_{i,j} = H(Q, K_{i,j}, h_{i,j} \\bmod q\\) and publishes the values \\(K_{i,j},h_{i,j},c_{i,j}\\) and \\(u_{i,j} = (R_{i,j} + c_{i,j}a_{i,j}) \\bmod q\\) . Important An election verifier must confirm (A) and (B) for each guardian \\(T_i\\) and for each \\(j \\in Z_k\\) : (A) The challenge \\(c_{i,j}\\) is correctly computed as \\[ c_{i,j} = H(Q,K_{i,j},h_{i,j}) \\bmod q \\] (B) The equation \\[ g_{u_{i,j}} \\bmod p = h_{i,j}K_{i,j}^{c_{i,j}} \\bmod p \\] is satisfied. It is worth noting here that for any fixed constant \\(\\alpha\\) , the value \\(g^{P_i(\\alpha)} \\bmod p\\) can be computed entirely from the published commitments as \\[ g^{P_i(\\alpha)} = g^{\\sum_{j=0}^{k-1}a_{i,j}\\alpha^j} \\bmod p= \\prod_{j=0}^{k-1}g_{a_{i,j}}\\alpha^j \\bmod p = \\prod_{j=0}^{k-1}(g^{a_{i,j}})^{\\alpha_j} \\bmod p = \\prod_{j=0}^{k-1} K_{i,j}^{\\alpha^j} \\] Info Although this formula includes double exponentiation \u2013 raising a given value to the power \\(\\alpha^j\\) \u2013 in what follows, \\(\\alpha\\) and \\(j\\) will always be small values (bounded by \\(n\\) ). This can also be reduced if desired since the same result will be achieved if the exponents \\(\\alpha^j\\) are reduced to \\(\\alpha^j \\bmod q\\) . To share secret values amongst each other, it is assumed that each guardian \\(T_i\\) has previously shared an auxiliary public encryption function \\(E_i\\) with the group. 3 Each guardian \\(T_i\\) then publishes the encryption \\(E_\\ell ( R_{i,\\ell}, P_i(\\ell))\\) for every other guardian \\(T_{\\ell}\\) \u2013 where \\(R_{i,\\ell}\\) is a random nonce. Guardian \\(T_{\\ell}\\) can now decrypt each \\(P_i(\\ell)\\) encrypted to its public key and verify its validity against the commitments made by \\(T_i\\) to its coefficients \\(K_{i,0},K_{i,0},\\ldots,K_{i,k-1},\\) by confirming that the following equation holds \\[ g^{P_i(\\ell)} \\bmod p = \\prod_{j=0}^{k-1}(K_{i,j})^{\\ell^j} \\bmod p \\] Guardians then publicly report having confirmed or failed to confirm this computation. If the recipient guardian \\(T_{\\ell}\\) reports not receiving a suitable value \\(P_i(\\ell)\\) , it becomes incumbent on the sending guardian \\(T_i\\) to publish this \\(P_i(\\ell)\\) , together with the nonce \\(R_{i,\\ell}\\) it used to encrypt \\(P_i(\\ell)\\) under the public key \\(E_{\\ell}\\) of recipient guardian \\(T_{\\ell}\\) . If guardian \\(T_i\\) fails to produce a suitable \\(P_i(\\ell)\\) and nonce \\(R_{i,\\ell}\\) that match both the published encryption and the above equation, it should be excluded from the election and the key generation process should be restarted with an alternate guardian. If, however, the published \\(P_i(\\ell)\\) and \\(R_{i,\\ell}\\) satisfy both the published encryption and the equation above, the claim of malfeasance is dismissed and the key generation process continues undeterred. 4 Once the baseline parameters have been produced and confirmed, all of the public commitments \\(K_{i,j}\\) are hashed together with the base hash \\(Q\\) to form an extended base hash \\(\\bar{Q}\\) that will form the basis of subsequent hash computations. The hash function SHA-256 will be used here and for all hash computations for the remainder of this document. Important An election verifier must verify the correct computation of the joint election public key (A) and extended base hash (B). (A) Joint election public key \\[ \\bar{Q}=H(Q,K_{1,0},K_{1,1},K_{1,2},\\ldots,K_{1,k-1},K_{2,0},K_{2,1},K_{2,2},\\ldots,K_{2,k-1},\\ldots,K_{n,0},K_{n,1},K_{n,2},\\ldots,K_{n,k-1}) \\] (B) Extended base hash \\[ K = \\prod_{i=1}^n K_i \\bmod p \\] Shamir A. How to Share a Secret. (1979) Communications of the ACM. \u21a9 NIST (2015) Secure Hash Standard (SHS). In: FIPS 180-4. https://csrc.nist.gov/publications/detail/fips/180/4/final \u21a9 A \u201ctraditional\u201d ElGamal public key is fine for this purpose. But the baseline ElectionGuard parameters \\(p\\) and \\(q\\) are tuned for homomorphic purposes and are not well-suited for encrypting large values. The ElectionGuard guardian keys can be used by breaking a message into small pieces ( e.g. individual bytes) and encrypting a large value as a sequence of small values. However, traditional public-key encryption methods are more efficient. Since this key is only used internally, its form is not specified herein. \u21a9 It is also permissible to dismiss any guardian that makes a false claim of malfeasance. However, this is not required as the sensitive information that is released as a result of the claim could have been released by the claimant in any case. \u21a9","title":"Key Generation"},{"location":"spec/0.95.0/4_Key_generation/#key-generation","text":"Before an election, the number of guardians \\((n)\\) is fixed together with a quorum value \\((k)\\) that describes the number of guardians necessary to decrypt tallies and produce election verification data. The values \\(n\\) and \\(k\\) are integers subject to the constraint that \\(1 \\le k \\le n\\) . Canvassing board members can often serve the role of election guardians, and typical values for \\(n\\) and \\(k\\) could be 5 and 3 \u2013 indicating that 3 of 5 canvassing board members must cooperate to produce the artifacts that enable election verification. The reason for not setting the quorum value \\(k\\) too low is that it will also be possible for \\(k\\) guardians to decrypt individual ballots. Info Note that decryption of individual ballots does not directly compromise voter privacy since links between encrypted ballots and the voters who cast them are not retained by the system. However, voters receive verification codes that can be associated with individual encrypted ballots, so any group that has the ability to decrypt individual ballots can also coerce voters by demanding to see their tracking codes. Threshold ElGamal encryption is used for encryption of ballots. This form of encryption makes it very easy to combine individual guardian public keys into a single public key for encrypting votes and ballots. It also offers a homomorphic property that allows individual encrypted votes to be combined to form encrypted tallies. The guardians of an election will each generate a public-private key pair. The public keys will then be combined (as described in the following section) into a single election public key which is used to encrypt all selections made by voters in the election. Ideally, at the conclusion of the election, each guardian will use its private key to form a verifiable partial decryption of each tally. These partial decryptions will then be combined to form full verifiable decryptions of the election tallies. To accommodate the possibility that one or more of the guardians will not be available at the conclusion of the election to form their partial decryptions, the guardians will cryptographically share 1 their private keys amongst each other during key generation in a manner to be detailed in the next section. A pre-determined threshold value \\((k)\\) out of the \\((n)\\) guardians will be necessary to produce a full decryption. Additionally, each guardian will also generate an auxiliary public-private key pair. These auxiliary keys will be used by the guardians to exchange fragments of their principal vote- encryption keys and for other scenarios in which non-vote data may need to be encrypted.","title":"Key Generation"},{"location":"spec/0.95.0/4_Key_generation/#overview-of-key-generation","text":"The \\(n\\) guardians of an election are denoted by \\(T_1,T_2,\\ldots, T_n\\) . Each guardian \\(T_i\\) generates an independent ElGamal public-private key pair by generating a random integer secret \\(s_i \\in Z_q\\) and forming the public key \\(K_i=g^{s_i}\\bmod p\\) . Each of these public keys will be published in the election record together with a non-interactive zero-knowledge Schnorr proof of knowledge of possession of the associated private key. The joint election public key will be \\[ K = \\prod_{i=1}^n K_i \\bmod p \\] To enable robustness and allow for the possibility of missing guardians at the conclusion of an election, the ElectionGuard key generation includes a sharing of private keys between guardians to enable decryption by any \\(k\\) guardians. This sharing is verifiable, so that receiving guardians can confirm that the shares they receive are meaningful; and the process allows for decryption without explicitly reconstructing private keys of missing guardians. Each guardian \\(T\\) generates \\(k-1\\) random polynomial coefficients \\(a_{i,j}\\) such that \\(0\\lt j \\lt k\\) and \\(0 \\le a_{i,j} \\le q\\) and forms the polynomial \\[ P_i(x) = \\sum_{j=0}^{k-1}a_{i,j}x^j\\bmod q \\] by setting \\(a_{i,0}\\) equal to its secret value \\(s_i\\) . Guardian \\(T_i\\) then publishes commitments \\(K_{i,j}= g^{a_{i,j}} \\bmod p\\) to each of its random polynomial coefficients. As with the primary secret keys, each guardian should provide a Schnorr proof of knowledge of the secret coefficient value \\(a_{i,j}\\) associated with each published commitment \\(K_{i,j}\\) . Since polynomial coefficients will be generated and managed in precisely the same fashion as secret keys, they will be treated together in a single step below. At the conclusion of the election, individual encrypted ballots will be homomorphically combined into a single encrypted aggregate ballot \u2013 consisting of an encryption of the tally for each option offered to voters. Each guardian will use its secret key to generate a partial decryption of each encrypted tally value, and these partial decryptions will be combined into full decryptions. If any election guardians are missing during tallying, any set of \\(k\\) guardians who are available can cooperate to reconstruct the missing partial decryption. All spoiled ballots are individually decrypted in precisely the same fashion.","title":"Overview of Key Generation"},{"location":"spec/0.95.0/4_Key_generation/#details-of-key-generation","text":"Each guardian \\(T\\) in an election with a decryption threshold of \\(k\\) generates \\(k\\) secret polynomial \\(i\\) coefficients \\(a_{i,j}\\) such that \\(0\\le j \\le k\\) and \\(0 \\le a_{i,j} \\lt q\\) and forms the polynomial \\[ P_i(x) = \\sum_{j=0}^{k-1} a_{i,j}x^j \\bmod q \\] Guardian \\(T_i\\) then publishes commitments \\(K_{i,j} = g^{a_{i,j}} \\bmod q\\) for each of its random polynomial coefficients. The constant term \\(a_{i,0}\\) of this polynomial will serve as the private key for guardian \\(T_i\\) and will also be denoted as \\(K_i = K_{i,0}\\) . In order to prove possession of the coefficient associated with each public commitment, for each \\(K_{i,j}\\) with \\(0 \\le j \\lt k\\) , guardian \\(T_i\\) generates a Schnorr proof of knowledge for each of its coefficients. This Non-Interactive Zero-Knowledge (NIZK) proof proceeds as follows.","title":"Details of Key Generation"},{"location":"spec/0.95.0/4_Key_generation/#nizk-shnorr-proof-by-guardian-of-knowledge-for-each-of-its-coefficients","text":"Formally: NIZK Proof by Guardian \\(T_i\\) of its knowledge of secrets \\(a_{i,j}\\) such that \\(K_{i,j}= g^{a_{i,j}} \\bmod p\\) For each \\(0 \\le j \\lt k\\) , Guardian \\(T_i\\) generates random integer values \\(R_{i,j}\\) in \\(Z_q\\) and computes \\(h_{i,j}=g^{R_{i,j}} \\bmod p\\) . Then, using the hash function SHA-256 (as defined in NIST PUB FIPS 180-4 2 ), guardian \\(T_i\\) then performs a single hash computation \\(c_{i,j} = H(Q, K_{i,j}, h_{i,j} \\bmod q\\) and publishes the values \\(K_{i,j},h_{i,j},c_{i,j}\\) and \\(u_{i,j} = (R_{i,j} + c_{i,j}a_{i,j}) \\bmod q\\) . Important An election verifier must confirm (A) and (B) for each guardian \\(T_i\\) and for each \\(j \\in Z_k\\) : (A) The challenge \\(c_{i,j}\\) is correctly computed as \\[ c_{i,j} = H(Q,K_{i,j},h_{i,j}) \\bmod q \\] (B) The equation \\[ g_{u_{i,j}} \\bmod p = h_{i,j}K_{i,j}^{c_{i,j}} \\bmod p \\] is satisfied. It is worth noting here that for any fixed constant \\(\\alpha\\) , the value \\(g^{P_i(\\alpha)} \\bmod p\\) can be computed entirely from the published commitments as \\[ g^{P_i(\\alpha)} = g^{\\sum_{j=0}^{k-1}a_{i,j}\\alpha^j} \\bmod p= \\prod_{j=0}^{k-1}g_{a_{i,j}}\\alpha^j \\bmod p = \\prod_{j=0}^{k-1}(g^{a_{i,j}})^{\\alpha_j} \\bmod p = \\prod_{j=0}^{k-1} K_{i,j}^{\\alpha^j} \\] Info Although this formula includes double exponentiation \u2013 raising a given value to the power \\(\\alpha^j\\) \u2013 in what follows, \\(\\alpha\\) and \\(j\\) will always be small values (bounded by \\(n\\) ). This can also be reduced if desired since the same result will be achieved if the exponents \\(\\alpha^j\\) are reduced to \\(\\alpha^j \\bmod q\\) . To share secret values amongst each other, it is assumed that each guardian \\(T_i\\) has previously shared an auxiliary public encryption function \\(E_i\\) with the group. 3 Each guardian \\(T_i\\) then publishes the encryption \\(E_\\ell ( R_{i,\\ell}, P_i(\\ell))\\) for every other guardian \\(T_{\\ell}\\) \u2013 where \\(R_{i,\\ell}\\) is a random nonce. Guardian \\(T_{\\ell}\\) can now decrypt each \\(P_i(\\ell)\\) encrypted to its public key and verify its validity against the commitments made by \\(T_i\\) to its coefficients \\(K_{i,0},K_{i,0},\\ldots,K_{i,k-1},\\) by confirming that the following equation holds \\[ g^{P_i(\\ell)} \\bmod p = \\prod_{j=0}^{k-1}(K_{i,j})^{\\ell^j} \\bmod p \\] Guardians then publicly report having confirmed or failed to confirm this computation. If the recipient guardian \\(T_{\\ell}\\) reports not receiving a suitable value \\(P_i(\\ell)\\) , it becomes incumbent on the sending guardian \\(T_i\\) to publish this \\(P_i(\\ell)\\) , together with the nonce \\(R_{i,\\ell}\\) it used to encrypt \\(P_i(\\ell)\\) under the public key \\(E_{\\ell}\\) of recipient guardian \\(T_{\\ell}\\) . If guardian \\(T_i\\) fails to produce a suitable \\(P_i(\\ell)\\) and nonce \\(R_{i,\\ell}\\) that match both the published encryption and the above equation, it should be excluded from the election and the key generation process should be restarted with an alternate guardian. If, however, the published \\(P_i(\\ell)\\) and \\(R_{i,\\ell}\\) satisfy both the published encryption and the equation above, the claim of malfeasance is dismissed and the key generation process continues undeterred. 4 Once the baseline parameters have been produced and confirmed, all of the public commitments \\(K_{i,j}\\) are hashed together with the base hash \\(Q\\) to form an extended base hash \\(\\bar{Q}\\) that will form the basis of subsequent hash computations. The hash function SHA-256 will be used here and for all hash computations for the remainder of this document. Important An election verifier must verify the correct computation of the joint election public key (A) and extended base hash (B). (A) Joint election public key \\[ \\bar{Q}=H(Q,K_{1,0},K_{1,1},K_{1,2},\\ldots,K_{1,k-1},K_{2,0},K_{2,1},K_{2,2},\\ldots,K_{2,k-1},\\ldots,K_{n,0},K_{n,1},K_{n,2},\\ldots,K_{n,k-1}) \\] (B) Extended base hash \\[ K = \\prod_{i=1}^n K_i \\bmod p \\] Shamir A. How to Share a Secret. (1979) Communications of the ACM. \u21a9 NIST (2015) Secure Hash Standard (SHS). In: FIPS 180-4. https://csrc.nist.gov/publications/detail/fips/180/4/final \u21a9 A \u201ctraditional\u201d ElGamal public key is fine for this purpose. But the baseline ElectionGuard parameters \\(p\\) and \\(q\\) are tuned for homomorphic purposes and are not well-suited for encrypting large values. The ElectionGuard guardian keys can be used by breaking a message into small pieces ( e.g. individual bytes) and encrypting a large value as a sequence of small values. However, traditional public-key encryption methods are more efficient. Since this key is only used internally, its form is not specified herein. \u21a9 It is also permissible to dismiss any guardian that makes a false claim of malfeasance. However, this is not required as the sensitive information that is released as a result of the claim could have been released by the claimant in any case. \u21a9","title":"NIZK Shnorr proof by Guardian of knowledge for each of its coefficients"},{"location":"spec/0.95.0/5_Ballot_encryption/","text":"Ballot Encryption An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). To enable homomorphic addition (for tallying), these values are exponentiated during encryption. Specifically, to encrypt a ballot entry \\((V)\\) , a random value \\(R\\) is selected such that \\(0 \\le R \\lt q\\) and the following computation is performed: Zero (not selected) is encrypted as \\[ (g^R \\bmod p, K^R \\bmod p) \\] One (selected) is encrypted as \\[ (g^R \\bmod p, g \\cdot K^R \\bmod p) \\] Note that if multiple encrypted votes \\[ \\left(g^{R_i} \\bmod p, g^{V_i} \\cdot K^{R_i} \\bmod p\\right) \\] are formed, their component-wise product \\[ \\left(g^{\\sum_{i}V_i} \\cdot K^{\\sum_{i}R_i} \\bmod p\\right) \\] serves as an encryption of \\(\\sum_iV_i\\) \u2013 which is the tally of those votes . 1 A contest in an election consists of a set of options together with a selection limit that indicates the number of selections that are allowed to be made in that contest. In most elections, most contests have a selection limit of one. However, a larger selection limit ( e.g. , select up to three) is not uncommon in some elections. Approval voting can be achieved by setting the selection limit to the total number of options in a contest. Ranked choice voting is not supported in this version of ElectionGuard , but it may be enabled in a future version. 2 Also, write-ins are assumed to be explicitly registered or allowed to be lumped into a single \"write-ins\" category for the purpose of verifiable tallying. Verifiable tallying of free-form write-ins may be best done with a MixNet 3 design. A legitimate vote in a contest consists of a set of selections with cardinality not exceeding the selection limit of that contest. To accommodate legitimate undervotes, the internal representation of a contest is augmented with \u201cplaceholder\u201d options equal in number to the selection limit. Placeholder options are selected as necessary to force the total number of selections made in a contest to be equal to the selection limit. When the selection limit is one, for example, the single placeholder option can be thought of as a \u201cnone of the above\u201d option. With larger selection limits, the number of placeholder options selected corresponds to the number of additional options that a voter could have selected in a contest. Info For efficiency, the placeholder options could be eliminated in an approval vote. However, to simplify the construction of election verifiers, we presume that placeholder options are always present \u2013 even for approval votes. Two things must now be proven about the encryption of each vote to ensure the integrity of a ballot. The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in each contest is equal to the selection limit for that contest (usually one). The use of ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. Chaum- Pedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013 particularly that a value is an encryption of either zero or one. The encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit \u2013 again using a Chaum-Pedersen proof. Info Note that the decryption of the selection limit could be more efficiently demonstrated by just releasing the sum of the nonces used for each of the individual encryptions. But, again to simplify the construction of election verifiers, a Chaum-Pedersen proof is used here as well. The \u201crandom\u201d nonces used for the ElGamal encryption of the ballot nonces are derived from a single 256-bit master nonce \\(R_B\\) for each ballot. For each contest listed in the ballot coding file, a contest nonce \\(R_C\\) is derived from the master nonce \\((R_B)\\) and the contest label \\((L_C)\\) as \\[ R_C= H(L_C,R_B) \\] using the hash function SHA-256. For each option listed in the ballot coding file, the nonce used to encrypt that option is derived from the contest nonce \\((R_C)\\) and the selection label for that option \\((L_S)\\) as \\[ R=H(L_S,R_C) \\] A user of ElectionGuard may optionally provide an additional public key. If such a key is provided, ElectionGuard uses that key to encrypt each ballot\u2019s master nonce \\(R_B\\) and return this encryption together with the encrypted ballot. Ballot nonces may be independent across different ballots, and only the nonces used to encrypt ballot selections need to be derived from the master nonce. The use of a single master nonce for each ballot allows the entire ballot encryption to be re-derived from the contents of a ballot and the master nonce. It also allows the encrypted ballot to be fully decrypted with the single master nonce. Outline for proofs of ballot correctness To prove that an ElGamal encryption pair \\((\\alpha, \\beta)\\) is an encryption of zero, the Chaum-Pedersen protocol proceeds as follows. NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero (given knowledge of encryption nonce \\(R\\) ) The prover selects a random value \\(u\\) in \\(Z_q\\) and commits to the pair \\[(g^u \\bmod p, K^u \\bmod p) \\] A hash computation is then performed (using the Fiat-Shamir heuristic) to create a pseudo-random challenge value \\[ c=H(\\bar{Q},(\\alpha,\\beta),(a,b)) \\] and the prover responds with \\[ v=(u + cR) \\bmod q \\] A verifier can now confirm the claim by checking that both \\[ g^V \\bmod p = a \\cdot \\alpha^C \\bmod p \\] and \\[ K^V \\bmod p = b \\cdot \\beta^{C} \\mod p \\] are true. NIZK Proof that \\((\\alpha,\\beta)\\) is an encryption of one (given knowledge of encryption nonce \\(R\\) ) To prove that \\((\\alpha, \\beta)\\) is an encryption of one, \\(\\frac{\\beta}{g} \\bmod p\\) is substituted for \\(\\beta\\) in the above. The verifier can be relieved of the need to perform a modular division by computing \\(\\beta \\bar{g} \\bmod p\\) rather than \\(\\beta \\bmod p\\) . As an alternative, the verifier can confirm that \\[ g^c \\cdot K^v \\bmod p = b \\cdot \\left(\\frac{\\beta}{g}\\right)^c \\] instead of \\[ K^v \\bmod p = b \\cdot \\left(\\frac{\\beta}{g}\\right)^c \\bmod p \\] As with many zero-knowledge protocols, if the prover knows a challenge value prior to making its commitment, it can create a false proof. For example, if a challenge \\(c\\) is known to be forthcoming, a prover can generate a random \\(v\\) in \\(Z_q\\) and commit to \\[ (a,b)=\\left(\\frac{g^v}{\u03b1^c} \\bmod p,\\frac{K^v}{\\beta^c} \\bmod p\\right)=\\left(g^v \\alpha^{(q-c)} \\bmod p,K^v \\beta^{(q-c)} \\bmod p\\right) \\] This selection will satisfy the required checks for (\u03b1,\u03b2) to appear as an encryption of zero regardless of the values of (\u03b1,\u03b2). Similarly, setting \\[ (a,b)=\\left(\\frac{g^v}{\u03b1^c} \\bmod p,\\frac{K^v g^c}{\u03b2^c} \\bmod p\\right)=\\left(g^v \u03b1^{(q-c)} \\bmod p,K^v \\beta^{(q-c)} \\bmod p\\right) \\] will satisfy the required checks for \\((\\alpha,\\beta)\\) to appear as an encryption of one regardless of the values of (\u03b1,\u03b2). This quirk is what enables the Cramer-Damg\u00e5rd-Schoenmakers technique to prove a disjunction of two predicates. Sketch of NIZK Proof that (\\alpha, \\beta) is an encryption of zero or one After the prover makes commitments \\((a_0,b_0 )\\) and \\((a_1,b_1 )\\) to the respective assertions that \\((\u03b1,\u03b2)\\) is an encryption of zero and \\((\u03b1,\u03b2)\\) is an encryption of one, a single challenge value \\(c\\) is selected by hashing all commitments and baseline parameters. The prover must then provide challenge values \\(c_0\\) and \\(c_1\\) such that \\(c=c_0+c_1 \\bmod q\\) . Since the prover has complete freedom to choose one of \\(c_0\\) and \\(c_1\\) , the prover can fix one value in advance \u2013 either \\(c_0\\) if \\((\u03b1,\u03b2)\\) is actually an encryption of one or \\(c_1\\) if \\((\u03b1,\u03b2)\\) is actually an encryption of zero. In response to the resulting challenge \\(c\\) , the prover uses this freedom to answer its faux claim with its chosen challenge value and then uses the remaining challenge value (as forced by the constraint that \\(c=(c_0+c_1 ) \\bmod q)\\) to demonstrate the truth of the other claim. An observer can see that one of the two claims must be true but cannot tell which. Details for proofs of ballot correctness The full protocol proceeds as follows \u2013 fully divided into the two cases. To encrypt an \u201cunselected\u201d option on a ballot, a random nonce R is selected uniformly Z_q and an encryption of zero is formed as \\[ (\u03b1,\u03b2)=(g^R \\bmod p,K^R \\bmod p) \\] NIZK Proof that \\((\\alpha,\\beta)\\) is an encryption of zero or one (given knowledge of encryption nonce \\(R\\) for which \\((\u03b1,\u03b2)\\) is an encryption of zero) To create the proof that \\((\u03b1,\u03b2)\\) is an encryption of a zero or a one, randomly select \\(c_1\\) , \\(v_1\\) , and \\(u_0\\) from \\(Z_q\\) and form the commitments \\[ (a_0,b_0 )=(g^{u_0} \\bmod p,K^{u_0} \\bmod p) \\] and \\[ (a_1,b_1 )=\\left(\\frac{g^{v_1}}{\\alpha^{c_1}} \\bmod p,\\frac{K^{v_1} g^{c_1}}{\\beta^{c_1}} \\bmod p\\right)=\\left(g^{v_1 } \\alpha^{(q-c_1)} \\bmod p,K^{v_1} g^{c_1} \\beta^{(q-c_1)} \\bmod p\\right) \\] A challenge value \\(c\\) is formed by hashing the extended base hash \\(\\bar{Q}\\) together with \\((\\alpha,\\beta)\\) , \\((a_0,b_0 )\\) , and \\((a_1,b_1 )\\) to form a challenge value \\[ c=H\\left(Q \u0305,(\u03b1,\u03b2),(a_0,b_0 ),(a_1,b_1 )\\right) \\] The proof is completed by forming \\(c_0=(c-c_1 ) \\bmod q\\) and \\(v_0=(u_0+c_0 \\cdot R) \\bmod q\\) and answering the challenge by returning \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . To encrypt a \u201cselected\u201d option on a ballot, a random nonce \\(R\\) is selected uniformly from \\(Z_q\\) and an encryption of one is formed as \\((\\alpha,\\beta)=(g^r \\bmod p, g \\cdot K^r \\bmod p)\\) . NIZK Proof that \\((\\alpha,\\beta)\\) is an encryption of zero or one (given knowledge of encryption nonce \\(R\\) for which \\((\\alpha,\\beta)\\) is an encryption of one) To create the proof that \\((\\alpha,\\beta)\\) is an encryption of a zero or a one, randomly select \\(c_0\\) , \\(v_0\\) , and \\(u_1\\) from \\(Z_q\\) and form the commitments \\[ (a_0,b_0) = \\left( \\frac{g^{v_0}}{\\alpha^{c_0}} \\bmod p,\\frac{K^{v_0}}{\\beta^{c_0 }} \\bmod p\\right) = \\left(g^{v_0} \u03b1^{(q-c_0)} \\bmod p,K^{v_0} \\beta^{(q-c_0 )} \\bmod p\\right) \\] and \\[ (a_1,b_1 )=(g^{u_1} \\bmod p,K^{u_1} \\bmod p) \\] A challenge value \\(c\\) is formed by hashing the extended base hash \\(\\bar{Q}\\) together with \\((\\alpha,\\beta)\\) , \\((a_0,b_0 )\\) , and \\((a_1,b_1 )\\) to form a challenge value \\[ c=H\\left(\\bar{Q},(\\alpha,\\beta),(a_0,b_0 ),(a_1,b_1 )\\right) \\] The proof is completed by forming \\[ c_1=(c-c_0 ) \\bmod q \\] and \\[ v_1=(u_1+c_1\\cdot R) \\bmod q \\] and answering the challenge by returning \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . In either of the two above cases, what is published in the election record is the encryption \\((\\alpha,\\beta)\\) together with the commitments \\((a_0,b_0 )\\) and \\((a_1,b_1 )\\) which are all hashed together with the election\u2019s extended base hash to form the challenge value c which is published together with values \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . Important An election verifier must confirm the following for each possible selection on a ballot: (A) The given values \\(\\alpha\\) , \\(\\beta\\) , \\(a_0\\) , \\(b_0\\) , \\(a_1\\) , and \\(b_1\\) are all in the set \\(Z_p^r\\) . (A value \\(x\\) is in \\(Z_p^r\\) if and only if \\(x\\) is an integer such that \\(0 \\le x \\lt p\\) and \\(x^q \\bmod p=1\\) is satisfied.) (B) The challenge \\(c\\) is correctly computed as \\[ c=H\\left(\\bar{Q},(\\alpha,\\beta),(a_0,b_0 ),(a_1,b_1 )\\right) \\] (C) The given values c_0, c_1, v_0, and v_1 are each in the set Z_q. (A value \\(x\\) is in \\(Z_q\\) if and only if \\(x\\) is an integer such that \\(0 \\le x \\lt q\\) ). (D) The equation \\[ c=(c_0+c_1 ) \\bmod q \\] is satisfied. (E) The equation \\[ g^{v_0} \\bmod p=a_0 \u03b1^{c_0} \\bmod p \\] is satisfied. (F) The equation \\[ g^{v_1} \\bmod p=a_1 \\alpha^{c_1} \\bmod p \\] is satisfied. (G) The equation \\[ K^{v_0} \\bmod p=b_0 \\beta^{c_0} \\bmod p \\] is satisfied. (H) The equation \\[ g^{c_1} K^{v_1} \\bmod p=b_1 \\beta^{c_1} \\bmod p \\] is satisfied. Proof of satisfying the selection limit The final step in proving that a ballot is well-formed is demonstrating that the selection limits for each contest have not been exceeded. This is accomplished by homomorphically combining all of the \\((\\alpha_i,\\beta_i )\\) values for a contest by forming the aggregate contest encryption \\[ (\\alpha,\\beta)=(\\prod_i \\alpha_i \\bmod p,\\prod_i \\beta_i \\bmod p) \\] and proving that \\((\\alpha,\\beta)\\) is an encryption of the total number of votes allowed for that contest (usually one). The simplest way to complete this proof is to combine all of the random nonces \\(R_i\\) that were used to form each \\[ (\\alpha_i,\\beta_i )=\\left(g^{R_i} \\bmod p,K^{R_i} \\bmod p\\right) \\] or \\[ (\\alpha_i,\\beta_i )=\\left(g^{R_i} \\bmod p,g \\cdot K^{R_i} \\bmod p\\right) \\] depending on whether the value encrypted is zero or one. The aggregate nonce \\[ R=\\sum_i R_i \\bmod q \\] matches the aggregate contest encryption as \\[ (\\alpha,\\beta)=(\\prod_i\\alpha_i \\bmod p,\\prod_i \\beta_i \\bmod p)= (g^R \\bmod p,g^L K^R \\bmod p) \\] where \\(L\\) is the selection limit for the contest. (Recall that \\(L\\) extra \u201cplaceholder\u201d positions will be added to each contest and set to one as necessary to ensure that exactly \\(L\\) selections are made for the contest.) NIZK Proof that \\((\\alpha,\\beta)\\) is an encryption of \\(L\\) (given knowledge of aggregate encryption nonce \\(R\\) ) An additional Chaum-Pedersen proof of \\((\\alpha,\\beta)\\) being an encryption of \\(L\\) is performed by selecting a random \\(U\\) in \\(Z_q\\) , publishing \\[ (a,b)=(g^U \\bmod p,K^U \\bmod p) \\] then hashing these values together with the election\u2019s extended base hash \\(\\bar{Q}\\) to form a pseudo-random challenge \\[ C=H\\left(\\bar{Q},(\\alpha,\\beta),(a,b)\\right) \\] and responding by publishing 4 \\[ V=(U+CR) \\bmod q \\] Note that all of the above proofs can be performed directly by the entity performing the public key encryption of a ballot without access to the decryption key(s). All that is required is the nonces \\(R_i\\) used for the individual selection encryptions. Important An election verifier must confirm the following for each contest on the ballot: (A) The number of placeholder positions matches the contest\u2019s selection limit \\(L\\) (B) The contest total \\((A,B)\\) satisfies \\[ A=\\prod_i \\alpha_i \\bmod p \\] and \\[ B=\\prod_i \\beta_i \\bmod p \\] where the \\((\\alpha_i,\\beta_i )\\) represent all possible selections (including placeholder selections) for the contest. (C) The given value \\(V\\) is in \\(Z_q\\) . (D) The given values \\(a\\) and \\(b\\) are each in \\(Z_p^r\\) . (E) The challenge value \\(C\\) is correctly computed as \\[ C=H\\left(\\bar{Q},(A,B),(a,b)\\right) \\] (F) The equation \\[ g^V \\bmod p=(aA^C ) \\bmod p \\] is satisfied. (G) The equation \\[ (g^{LC} K^V) \\bmod p=(bB^C ) \\bmod p \\] is satisfied. Verification Codes Upon completion of the encryption of each ballot, a verification code is prepared for each voter. The code is a running hash that begins with the extended base hash code \\(\\bar{Q}\\) and includes an identifier for the voting device, the location of the voting device, the date and time that the ballot was encrypted, and, of course, the encryption of the ballot itself. The hash \\((H)\\) used for this purpose is SHA-256. The tracking code is formed as follows. \\[ H_0=H(\\bar{Q}) \\] where \\(\\bar{Q}\\) is the extended base hash code of the election. For ballot with index \\(i>0\\) , \\[ H_i=H(H_{i-1},D,T,B_i) \\] where \\(D\\) consists of the voting device information described above, \\(T\\) is the date and time of ballot encryption, and \\(B_i\\) is an ordered list of the individual encryptions on the ballot \u2013 with the ordering as specified by the ballot coding file. At the conclusion of a voting period (this may be the end of a day in a multi-day election), the hash chain is closed by computing \\[ \\bar{H}=H(H_l, \\text{\u201cCLOSE\"}) \\] where \\(H_l\\) is the final tracking code produced by that device during that voting period. The close of the hash chain can be computed either by the voting device or subsequently by election administrators, and it is published as part of the election record. Important An election verifier must confirm that each of the values in the running hash is correctly computed. Specifically, an election verifier must confirm each of the following. (A) The equation \\(H_0=H(\\bar{Q})\\) is satisfied. (B) For each ballot \\[ B_i, H_i=H\\left(H_{i-1},D,T,B_i\\right) \\] is satisfied. (C) The closing hash \\[ \\bar{H}=H(H_l,\\text{\u201cCLOSE\"}) \\] is correctly computed from the final tracking code \\(H_l\\) Once in possession of a tracking code ( and never before ), a voter is afforded an option to either cast the associated ballot or spoil it and restart the ballot preparation process. The precise mechanism for voters to make these selections may vary depending upon the instantiation, but this choice would ordinarily be made immediately after a voter is presented with the tracking code, and the status of the ballot would be undetermined until the decision is made. It is possible, for instance, for a voter to make the decision directly on the voting device, or a voter may instead be afforded an option to deposit the ballot in a receptacle or to take it to a poll worker to be spoiled. For vote-by-mail scenarios, a voter can be sent (hashes of) two complete sets of encryptions for each selectable option and can effect a ballot challenge implicitly by choosing which encryptions to return. The initial decryption actually forms the value \\(g^\\sum_i V_i \\bmod p\\) . However, since \\(\\sum_i V_i\\) is a relatively small value, it can be effectively computed from \\(g^\\sum_i V_i \\bmod p\\) by means of an exhaustive search or similar methods. \u21a9 Benaloh J., Moran. T, Naish L., Ramchen K., and Teague V. Shuffle-Sum: Coercion-Resistant Verifiable Tallying for STV Voting (2009) in Transactions of Information Forensics and Security \u21a9 Chaum D. Untraceable Electronic Mail, Return Addresses, and Digital Pseudonyms (1981) Communications of the ACM \u21a9 One could simply release the aggregate nonce \\(R=\\prod_i R_i \\bmod q\\) to complete this proof. However, since Chaum-Pedersen proofs are being performed elsewhere, it is simpler for a verifier to just repeat the same steps. \u21a9","title":"Ballot Encryption"},{"location":"spec/0.95.0/5_Ballot_encryption/#ballot-encryption","text":"An ElectionGuard ballot is comprised entirely of encryptions of one (indicating selection made) and zero (indicating selection not made). To enable homomorphic addition (for tallying), these values are exponentiated during encryption. Specifically, to encrypt a ballot entry \\((V)\\) , a random value \\(R\\) is selected such that \\(0 \\le R \\lt q\\) and the following computation is performed: Zero (not selected) is encrypted as \\[ (g^R \\bmod p, K^R \\bmod p) \\] One (selected) is encrypted as \\[ (g^R \\bmod p, g \\cdot K^R \\bmod p) \\] Note that if multiple encrypted votes \\[ \\left(g^{R_i} \\bmod p, g^{V_i} \\cdot K^{R_i} \\bmod p\\right) \\] are formed, their component-wise product \\[ \\left(g^{\\sum_{i}V_i} \\cdot K^{\\sum_{i}R_i} \\bmod p\\right) \\] serves as an encryption of \\(\\sum_iV_i\\) \u2013 which is the tally of those votes . 1 A contest in an election consists of a set of options together with a selection limit that indicates the number of selections that are allowed to be made in that contest. In most elections, most contests have a selection limit of one. However, a larger selection limit ( e.g. , select up to three) is not uncommon in some elections. Approval voting can be achieved by setting the selection limit to the total number of options in a contest. Ranked choice voting is not supported in this version of ElectionGuard , but it may be enabled in a future version. 2 Also, write-ins are assumed to be explicitly registered or allowed to be lumped into a single \"write-ins\" category for the purpose of verifiable tallying. Verifiable tallying of free-form write-ins may be best done with a MixNet 3 design. A legitimate vote in a contest consists of a set of selections with cardinality not exceeding the selection limit of that contest. To accommodate legitimate undervotes, the internal representation of a contest is augmented with \u201cplaceholder\u201d options equal in number to the selection limit. Placeholder options are selected as necessary to force the total number of selections made in a contest to be equal to the selection limit. When the selection limit is one, for example, the single placeholder option can be thought of as a \u201cnone of the above\u201d option. With larger selection limits, the number of placeholder options selected corresponds to the number of additional options that a voter could have selected in a contest. Info For efficiency, the placeholder options could be eliminated in an approval vote. However, to simplify the construction of election verifiers, we presume that placeholder options are always present \u2013 even for approval votes. Two things must now be proven about the encryption of each vote to ensure the integrity of a ballot. The encryption associated with each option is either an encryption of zero or an encryption of one. The sum of all encrypted values in each contest is equal to the selection limit for that contest (usually one). The use of ElGamal encryption enables efficient zero-knowledge proofs of these requirements, and the Fiat-Shamir heuristic can be used to make these proofs non-interactive. Chaum- Pedersen proofs are used to demonstrate that an encryption is that of a specified value, and these are combined with the Cramer-Damg\u00e5rd-Schoenmakers technique to show that an encryption is that of one of a specified set of values \u2013 particularly that a value is an encryption of either zero or one. The encryptions of selections in a contest are homomorphically combined, and the result is shown to be an encryption of that contest\u2019s selection limit \u2013 again using a Chaum-Pedersen proof. Info Note that the decryption of the selection limit could be more efficiently demonstrated by just releasing the sum of the nonces used for each of the individual encryptions. But, again to simplify the construction of election verifiers, a Chaum-Pedersen proof is used here as well. The \u201crandom\u201d nonces used for the ElGamal encryption of the ballot nonces are derived from a single 256-bit master nonce \\(R_B\\) for each ballot. For each contest listed in the ballot coding file, a contest nonce \\(R_C\\) is derived from the master nonce \\((R_B)\\) and the contest label \\((L_C)\\) as \\[ R_C= H(L_C,R_B) \\] using the hash function SHA-256. For each option listed in the ballot coding file, the nonce used to encrypt that option is derived from the contest nonce \\((R_C)\\) and the selection label for that option \\((L_S)\\) as \\[ R=H(L_S,R_C) \\] A user of ElectionGuard may optionally provide an additional public key. If such a key is provided, ElectionGuard uses that key to encrypt each ballot\u2019s master nonce \\(R_B\\) and return this encryption together with the encrypted ballot. Ballot nonces may be independent across different ballots, and only the nonces used to encrypt ballot selections need to be derived from the master nonce. The use of a single master nonce for each ballot allows the entire ballot encryption to be re-derived from the contents of a ballot and the master nonce. It also allows the encrypted ballot to be fully decrypted with the single master nonce.","title":"Ballot Encryption"},{"location":"spec/0.95.0/5_Ballot_encryption/#outline-for-proofs-of-ballot-correctness","text":"To prove that an ElGamal encryption pair \\((\\alpha, \\beta)\\) is an encryption of zero, the Chaum-Pedersen protocol proceeds as follows.","title":"Outline for proofs of ballot correctness"},{"location":"spec/0.95.0/5_Ballot_encryption/#nizk-proof-that-alpha-beta-is-an-encryption-of-zero-given-knowledge-of-encryption-nonce-r","text":"The prover selects a random value \\(u\\) in \\(Z_q\\) and commits to the pair \\[(g^u \\bmod p, K^u \\bmod p) \\] A hash computation is then performed (using the Fiat-Shamir heuristic) to create a pseudo-random challenge value \\[ c=H(\\bar{Q},(\\alpha,\\beta),(a,b)) \\] and the prover responds with \\[ v=(u + cR) \\bmod q \\] A verifier can now confirm the claim by checking that both \\[ g^V \\bmod p = a \\cdot \\alpha^C \\bmod p \\] and \\[ K^V \\bmod p = b \\cdot \\beta^{C} \\mod p \\] are true.","title":"NIZK Proof that \\((\\alpha, \\beta)\\) is an encryption of zero (given knowledge of encryption nonce \\(R\\))"},{"location":"spec/0.95.0/5_Ballot_encryption/#nizk-proof-that-alphabeta-is-an-encryption-of-one-given-knowledge-of-encryption-nonce-r","text":"To prove that \\((\\alpha, \\beta)\\) is an encryption of one, \\(\\frac{\\beta}{g} \\bmod p\\) is substituted for \\(\\beta\\) in the above. The verifier can be relieved of the need to perform a modular division by computing \\(\\beta \\bar{g} \\bmod p\\) rather than \\(\\beta \\bmod p\\) . As an alternative, the verifier can confirm that \\[ g^c \\cdot K^v \\bmod p = b \\cdot \\left(\\frac{\\beta}{g}\\right)^c \\] instead of \\[ K^v \\bmod p = b \\cdot \\left(\\frac{\\beta}{g}\\right)^c \\bmod p \\] As with many zero-knowledge protocols, if the prover knows a challenge value prior to making its commitment, it can create a false proof. For example, if a challenge \\(c\\) is known to be forthcoming, a prover can generate a random \\(v\\) in \\(Z_q\\) and commit to \\[ (a,b)=\\left(\\frac{g^v}{\u03b1^c} \\bmod p,\\frac{K^v}{\\beta^c} \\bmod p\\right)=\\left(g^v \\alpha^{(q-c)} \\bmod p,K^v \\beta^{(q-c)} \\bmod p\\right) \\] This selection will satisfy the required checks for (\u03b1,\u03b2) to appear as an encryption of zero regardless of the values of (\u03b1,\u03b2). Similarly, setting \\[ (a,b)=\\left(\\frac{g^v}{\u03b1^c} \\bmod p,\\frac{K^v g^c}{\u03b2^c} \\bmod p\\right)=\\left(g^v \u03b1^{(q-c)} \\bmod p,K^v \\beta^{(q-c)} \\bmod p\\right) \\] will satisfy the required checks for \\((\\alpha,\\beta)\\) to appear as an encryption of one regardless of the values of (\u03b1,\u03b2). This quirk is what enables the Cramer-Damg\u00e5rd-Schoenmakers technique to prove a disjunction of two predicates.","title":"NIZK Proof that \\((\\alpha,\\beta)\\) is an encryption of one (given knowledge of encryption nonce \\(R\\))"},{"location":"spec/0.95.0/5_Ballot_encryption/#sketch-of-nizk-proof-that-alpha-beta-is-an-encryption-of-zero-or-one","text":"After the prover makes commitments \\((a_0,b_0 )\\) and \\((a_1,b_1 )\\) to the respective assertions that \\((\u03b1,\u03b2)\\) is an encryption of zero and \\((\u03b1,\u03b2)\\) is an encryption of one, a single challenge value \\(c\\) is selected by hashing all commitments and baseline parameters. The prover must then provide challenge values \\(c_0\\) and \\(c_1\\) such that \\(c=c_0+c_1 \\bmod q\\) . Since the prover has complete freedom to choose one of \\(c_0\\) and \\(c_1\\) , the prover can fix one value in advance \u2013 either \\(c_0\\) if \\((\u03b1,\u03b2)\\) is actually an encryption of one or \\(c_1\\) if \\((\u03b1,\u03b2)\\) is actually an encryption of zero. In response to the resulting challenge \\(c\\) , the prover uses this freedom to answer its faux claim with its chosen challenge value and then uses the remaining challenge value (as forced by the constraint that \\(c=(c_0+c_1 ) \\bmod q)\\) to demonstrate the truth of the other claim. An observer can see that one of the two claims must be true but cannot tell which.","title":"Sketch of NIZK Proof that (\\alpha, \\beta) is an encryption of zero or one"},{"location":"spec/0.95.0/5_Ballot_encryption/#details-for-proofs-of-ballot-correctness","text":"The full protocol proceeds as follows \u2013 fully divided into the two cases. To encrypt an \u201cunselected\u201d option on a ballot, a random nonce R is selected uniformly Z_q and an encryption of zero is formed as \\[ (\u03b1,\u03b2)=(g^R \\bmod p,K^R \\bmod p) \\]","title":"Details for proofs of ballot correctness"},{"location":"spec/0.95.0/5_Ballot_encryption/#nizk-proof-that-alphabeta-is-an-encryption-of-zero-or-one-given-knowledge-of-encryption-nonce-r-for-which-is-an-encryption-of-zero","text":"To create the proof that \\((\u03b1,\u03b2)\\) is an encryption of a zero or a one, randomly select \\(c_1\\) , \\(v_1\\) , and \\(u_0\\) from \\(Z_q\\) and form the commitments \\[ (a_0,b_0 )=(g^{u_0} \\bmod p,K^{u_0} \\bmod p) \\] and \\[ (a_1,b_1 )=\\left(\\frac{g^{v_1}}{\\alpha^{c_1}} \\bmod p,\\frac{K^{v_1} g^{c_1}}{\\beta^{c_1}} \\bmod p\\right)=\\left(g^{v_1 } \\alpha^{(q-c_1)} \\bmod p,K^{v_1} g^{c_1} \\beta^{(q-c_1)} \\bmod p\\right) \\] A challenge value \\(c\\) is formed by hashing the extended base hash \\(\\bar{Q}\\) together with \\((\\alpha,\\beta)\\) , \\((a_0,b_0 )\\) , and \\((a_1,b_1 )\\) to form a challenge value \\[ c=H\\left(Q \u0305,(\u03b1,\u03b2),(a_0,b_0 ),(a_1,b_1 )\\right) \\] The proof is completed by forming \\(c_0=(c-c_1 ) \\bmod q\\) and \\(v_0=(u_0+c_0 \\cdot R) \\bmod q\\) and answering the challenge by returning \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . To encrypt a \u201cselected\u201d option on a ballot, a random nonce \\(R\\) is selected uniformly from \\(Z_q\\) and an encryption of one is formed as \\((\\alpha,\\beta)=(g^r \\bmod p, g \\cdot K^r \\bmod p)\\) .","title":"NIZK Proof that \\((\\alpha,\\beta)\\) is an encryption of zero or one (given knowledge of encryption nonce \\(R\\) for which \\((\u03b1,\u03b2)\\) is an encryption of zero)"},{"location":"spec/0.95.0/5_Ballot_encryption/#nizk-proof-that-alphabeta-is-an-encryption-of-zero-or-one-given-knowledge-of-encryption-nonce-r-for-which-alphabeta-is-an-encryption-of-one","text":"To create the proof that \\((\\alpha,\\beta)\\) is an encryption of a zero or a one, randomly select \\(c_0\\) , \\(v_0\\) , and \\(u_1\\) from \\(Z_q\\) and form the commitments \\[ (a_0,b_0) = \\left( \\frac{g^{v_0}}{\\alpha^{c_0}} \\bmod p,\\frac{K^{v_0}}{\\beta^{c_0 }} \\bmod p\\right) = \\left(g^{v_0} \u03b1^{(q-c_0)} \\bmod p,K^{v_0} \\beta^{(q-c_0 )} \\bmod p\\right) \\] and \\[ (a_1,b_1 )=(g^{u_1} \\bmod p,K^{u_1} \\bmod p) \\] A challenge value \\(c\\) is formed by hashing the extended base hash \\(\\bar{Q}\\) together with \\((\\alpha,\\beta)\\) , \\((a_0,b_0 )\\) , and \\((a_1,b_1 )\\) to form a challenge value \\[ c=H\\left(\\bar{Q},(\\alpha,\\beta),(a_0,b_0 ),(a_1,b_1 )\\right) \\] The proof is completed by forming \\[ c_1=(c-c_0 ) \\bmod q \\] and \\[ v_1=(u_1+c_1\\cdot R) \\bmod q \\] and answering the challenge by returning \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . In either of the two above cases, what is published in the election record is the encryption \\((\\alpha,\\beta)\\) together with the commitments \\((a_0,b_0 )\\) and \\((a_1,b_1 )\\) which are all hashed together with the election\u2019s extended base hash to form the challenge value c which is published together with values \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) . Important An election verifier must confirm the following for each possible selection on a ballot: (A) The given values \\(\\alpha\\) , \\(\\beta\\) , \\(a_0\\) , \\(b_0\\) , \\(a_1\\) , and \\(b_1\\) are all in the set \\(Z_p^r\\) . (A value \\(x\\) is in \\(Z_p^r\\) if and only if \\(x\\) is an integer such that \\(0 \\le x \\lt p\\) and \\(x^q \\bmod p=1\\) is satisfied.) (B) The challenge \\(c\\) is correctly computed as \\[ c=H\\left(\\bar{Q},(\\alpha,\\beta),(a_0,b_0 ),(a_1,b_1 )\\right) \\] (C) The given values c_0, c_1, v_0, and v_1 are each in the set Z_q. (A value \\(x\\) is in \\(Z_q\\) if and only if \\(x\\) is an integer such that \\(0 \\le x \\lt q\\) ). (D) The equation \\[ c=(c_0+c_1 ) \\bmod q \\] is satisfied. (E) The equation \\[ g^{v_0} \\bmod p=a_0 \u03b1^{c_0} \\bmod p \\] is satisfied. (F) The equation \\[ g^{v_1} \\bmod p=a_1 \\alpha^{c_1} \\bmod p \\] is satisfied. (G) The equation \\[ K^{v_0} \\bmod p=b_0 \\beta^{c_0} \\bmod p \\] is satisfied. (H) The equation \\[ g^{c_1} K^{v_1} \\bmod p=b_1 \\beta^{c_1} \\bmod p \\] is satisfied.","title":"NIZK Proof that \\((\\alpha,\\beta)\\) is an encryption of zero or one (given knowledge of encryption nonce \\(R\\) for which \\((\\alpha,\\beta)\\) is an encryption of one)"},{"location":"spec/0.95.0/5_Ballot_encryption/#proof-of-satisfying-the-selection-limit","text":"The final step in proving that a ballot is well-formed is demonstrating that the selection limits for each contest have not been exceeded. This is accomplished by homomorphically combining all of the \\((\\alpha_i,\\beta_i )\\) values for a contest by forming the aggregate contest encryption \\[ (\\alpha,\\beta)=(\\prod_i \\alpha_i \\bmod p,\\prod_i \\beta_i \\bmod p) \\] and proving that \\((\\alpha,\\beta)\\) is an encryption of the total number of votes allowed for that contest (usually one). The simplest way to complete this proof is to combine all of the random nonces \\(R_i\\) that were used to form each \\[ (\\alpha_i,\\beta_i )=\\left(g^{R_i} \\bmod p,K^{R_i} \\bmod p\\right) \\] or \\[ (\\alpha_i,\\beta_i )=\\left(g^{R_i} \\bmod p,g \\cdot K^{R_i} \\bmod p\\right) \\] depending on whether the value encrypted is zero or one. The aggregate nonce \\[ R=\\sum_i R_i \\bmod q \\] matches the aggregate contest encryption as \\[ (\\alpha,\\beta)=(\\prod_i\\alpha_i \\bmod p,\\prod_i \\beta_i \\bmod p)= (g^R \\bmod p,g^L K^R \\bmod p) \\] where \\(L\\) is the selection limit for the contest. (Recall that \\(L\\) extra \u201cplaceholder\u201d positions will be added to each contest and set to one as necessary to ensure that exactly \\(L\\) selections are made for the contest.)","title":"Proof of satisfying the selection limit"},{"location":"spec/0.95.0/5_Ballot_encryption/#nizk-proof-that-alphabeta-is-an-encryption-of-l-given-knowledge-of-aggregate-encryption-nonce-r","text":"An additional Chaum-Pedersen proof of \\((\\alpha,\\beta)\\) being an encryption of \\(L\\) is performed by selecting a random \\(U\\) in \\(Z_q\\) , publishing \\[ (a,b)=(g^U \\bmod p,K^U \\bmod p) \\] then hashing these values together with the election\u2019s extended base hash \\(\\bar{Q}\\) to form a pseudo-random challenge \\[ C=H\\left(\\bar{Q},(\\alpha,\\beta),(a,b)\\right) \\] and responding by publishing 4 \\[ V=(U+CR) \\bmod q \\] Note that all of the above proofs can be performed directly by the entity performing the public key encryption of a ballot without access to the decryption key(s). All that is required is the nonces \\(R_i\\) used for the individual selection encryptions. Important An election verifier must confirm the following for each contest on the ballot: (A) The number of placeholder positions matches the contest\u2019s selection limit \\(L\\) (B) The contest total \\((A,B)\\) satisfies \\[ A=\\prod_i \\alpha_i \\bmod p \\] and \\[ B=\\prod_i \\beta_i \\bmod p \\] where the \\((\\alpha_i,\\beta_i )\\) represent all possible selections (including placeholder selections) for the contest. (C) The given value \\(V\\) is in \\(Z_q\\) . (D) The given values \\(a\\) and \\(b\\) are each in \\(Z_p^r\\) . (E) The challenge value \\(C\\) is correctly computed as \\[ C=H\\left(\\bar{Q},(A,B),(a,b)\\right) \\] (F) The equation \\[ g^V \\bmod p=(aA^C ) \\bmod p \\] is satisfied. (G) The equation \\[ (g^{LC} K^V) \\bmod p=(bB^C ) \\bmod p \\] is satisfied.","title":"NIZK Proof that \\((\\alpha,\\beta)\\) is an encryption of \\(L\\) (given knowledge of aggregate encryption nonce \\(R\\))"},{"location":"spec/0.95.0/5_Ballot_encryption/#verification-codes","text":"Upon completion of the encryption of each ballot, a verification code is prepared for each voter. The code is a running hash that begins with the extended base hash code \\(\\bar{Q}\\) and includes an identifier for the voting device, the location of the voting device, the date and time that the ballot was encrypted, and, of course, the encryption of the ballot itself. The hash \\((H)\\) used for this purpose is SHA-256. The tracking code is formed as follows. \\[ H_0=H(\\bar{Q}) \\] where \\(\\bar{Q}\\) is the extended base hash code of the election. For ballot with index \\(i>0\\) , \\[ H_i=H(H_{i-1},D,T,B_i) \\] where \\(D\\) consists of the voting device information described above, \\(T\\) is the date and time of ballot encryption, and \\(B_i\\) is an ordered list of the individual encryptions on the ballot \u2013 with the ordering as specified by the ballot coding file. At the conclusion of a voting period (this may be the end of a day in a multi-day election), the hash chain is closed by computing \\[ \\bar{H}=H(H_l, \\text{\u201cCLOSE\"}) \\] where \\(H_l\\) is the final tracking code produced by that device during that voting period. The close of the hash chain can be computed either by the voting device or subsequently by election administrators, and it is published as part of the election record. Important An election verifier must confirm that each of the values in the running hash is correctly computed. Specifically, an election verifier must confirm each of the following. (A) The equation \\(H_0=H(\\bar{Q})\\) is satisfied. (B) For each ballot \\[ B_i, H_i=H\\left(H_{i-1},D,T,B_i\\right) \\] is satisfied. (C) The closing hash \\[ \\bar{H}=H(H_l,\\text{\u201cCLOSE\"}) \\] is correctly computed from the final tracking code \\(H_l\\) Once in possession of a tracking code ( and never before ), a voter is afforded an option to either cast the associated ballot or spoil it and restart the ballot preparation process. The precise mechanism for voters to make these selections may vary depending upon the instantiation, but this choice would ordinarily be made immediately after a voter is presented with the tracking code, and the status of the ballot would be undetermined until the decision is made. It is possible, for instance, for a voter to make the decision directly on the voting device, or a voter may instead be afforded an option to deposit the ballot in a receptacle or to take it to a poll worker to be spoiled. For vote-by-mail scenarios, a voter can be sent (hashes of) two complete sets of encryptions for each selectable option and can effect a ballot challenge implicitly by choosing which encryptions to return. The initial decryption actually forms the value \\(g^\\sum_i V_i \\bmod p\\) . However, since \\(\\sum_i V_i\\) is a relatively small value, it can be effectively computed from \\(g^\\sum_i V_i \\bmod p\\) by means of an exhaustive search or similar methods. \u21a9 Benaloh J., Moran. T, Naish L., Ramchen K., and Teague V. Shuffle-Sum: Coercion-Resistant Verifiable Tallying for STV Voting (2009) in Transactions of Information Forensics and Security \u21a9 Chaum D. Untraceable Electronic Mail, Return Addresses, and Digital Pseudonyms (1981) Communications of the ACM \u21a9 One could simply release the aggregate nonce \\(R=\\prod_i R_i \\bmod q\\) to complete this proof. However, since Chaum-Pedersen proofs are being performed elsewhere, it is simpler for a verifier to just repeat the same steps. \u21a9","title":"Verification Codes"},{"location":"spec/0.95.0/6_Ballot_aggregation/","text":"Ballot Aggregation At the conclusion of voting, all of the ballot encryptions are published in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically combined to form an encryption of the total number of times that option was selected. The encryptions \\((\\alpha_i,\\beta_i )\\) of each individual option are combined by forming the product \\[ (A,B)=\\left(\\prod_i \\alpha_i\\bmod p, \\prod_i \\beta_i \\bmod p\\right) \\] This aggregate encryption \\((A,B)\\) , which represents an encryption of the tally of that option, is published in the election record for each option. Important An election verifier must confirm for each (non-placeholder) option in each contest in the ballot coding file that the aggregate encryption (A,B) satisfies \\(A=\\prod_j \\alpha_j\\) and \\(B=\\prod_j \\beta_j\\) where the \\((\\alpha_j,\\beta_j)\\) are the corresponding encryptions on all cast ballots in the election record.","title":"Ballot Aggregation"},{"location":"spec/0.95.0/6_Ballot_aggregation/#ballot-aggregation","text":"At the conclusion of voting, all of the ballot encryptions are published in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically combined to form an encryption of the total number of times that option was selected. The encryptions \\((\\alpha_i,\\beta_i )\\) of each individual option are combined by forming the product \\[ (A,B)=\\left(\\prod_i \\alpha_i\\bmod p, \\prod_i \\beta_i \\bmod p\\right) \\] This aggregate encryption \\((A,B)\\) , which represents an encryption of the tally of that option, is published in the election record for each option. Important An election verifier must confirm for each (non-placeholder) option in each contest in the ballot coding file that the aggregate encryption (A,B) satisfies \\(A=\\prod_j \\alpha_j\\) and \\(B=\\prod_j \\beta_j\\) where the \\((\\alpha_j,\\beta_j)\\) are the corresponding encryptions on all cast ballots in the election record.","title":"Ballot Aggregation"},{"location":"spec/0.95.0/7_Verifiable_decryption/","text":"Verifiable Decryption Discussion To decrypt an aggregate encryption \\((A,B)\\) (or an individual encryption such as one on a spoiled ballot), each available election guardian \\(T_i\\) uses its secret key \\(s_i\\) to compute its share of the decryption as \\[ M_i=A^{s_i} \\bmod p \\] Each guardian \\(T_i\\) also publishes a Chaum-Pedersen proof of the correctness of \\(M_i\\) as follows. NIZK Proof by Guardian \\(T_i\\) of knowledge of \\(s_i \\in Z_p^r\\) for which both \\(M_i=A^{s_i} \\bmod p\\) and \\(K_i=g^{s_i} \\bmod p\\) Guardian \\(T_i\\) selects a random value \\(u_i\\) in \\(Z_q\\) and commits to the pair \\[ (a_i,b_i )=\\left(g^{u_i} \\bmod p,A^{u_i} \\bmod p\\right) \\] The values \\((A,B)\\) , \\((a_i,b_i )\\) , and \\(M_i\\) are hashed together with the extended base hash value \\(\\bar{Q}\\) to form a challenge value \\[ c_i=H\\left(\\bar{Q},(A,B),(a_i,b_i ),M_i \\right) \\] and guardian T_i responds with \\[ v_i=(u_i+c_i s_i ) \\bmod q \\] Important An election verifier must then confirm for each (non-placeholder) option in each contest in the ballot coding file the following for each decrypting guardian \\(T_i\\) . (A) The given value \\(v_i\\) is in the set \\(Z_q\\) . (B) The given values \\(a_i\\) and \\(b_i\\) are both in the set \\(Z_q^r\\) . (C) The challenge value \\(c_i\\) satisfies \\[ c_i=H\\left(\\bar{Q},(A,B),(a_i,b_i ),M_i \\right) \\] (D) The equation \\[ g^(v_i ) mod p=(a_i K_i^{c_i} ) \\bmod p \\] is satisfied. (E) The equation \\[ A^{v_i} \\bmod p=(b_i M_i^{c_i} ) \\bmod p \\] is satisfied. Decryption when all guardians are present If all guardians are present and have posted suitable proofs, the next step is to publish the value \\[ M=\\frac{B}{\\left(\\prod_{i=1}^n{M_i}\\right)} \\bmod p \\] This \\(M\\) has the property that \\(M=g^t \\bmod p\\) where \\(t\\) is the tally of the associated option. In general, computation of this tally value t is computationally intractable. However, in this application, t is relatively small \u2013 bounded by the number of votes cast. Election administrators can determine this tally value t from M by exhaustive search, by precomputing a table of all possible M values in the allowable range and then performing a single look-up, or by a combination in which some exponentiations are precomputed and a small search is used to find the value of t (e.g., a partial table consisting of g^100 mod p, g^200 mod p, g^300 mod p, \u2026 is precomputed and the value M is repeatedly divided by g until a value is found that is in the partial table). The value t is published in the election record, and verifiers should check both that M=g^t mod p and that \\[ B= \\left(M\u22c5\\prod_{i=1}^n M_i \\right) \\bmod p \\] Decryption with missing guardians If one or more of the election guardians are not available for decryption, any k available guardians can use the information they have to reconstruct the partial decryptions for missing guardians as follows. If guardian \\(T_i\\) is missing during decryption, each of at least \\(k\\) available guardians \\(T_l\\) should use its share \\(P_i (l)\\) of the secret value \\(s_i\\) previously shared by \\(T_i\\) to compute a share of the missing partial decryption \\(M_i\\) in the same way that it used its own secret \\(s_l\\) . Specifically, guardian \\(T_l\\) publishes partial decryption share \\[ M_{i,l}=A^{P_i (l)} \\bmod p \\] Guardian \\(T_l\\) also publishes a Chaum-Pedersen proof of the correctness of \\(M_(i,l)\\) as follows. NIZK Proof by Guardian \\(T_l\\) of knowledge of \\(s_{i,l} \\in Z_p^r\\) for which both \\(M_{i,l}=A^{s_{i,l}} \\bmod p\\) and \\(g^{s_i} \\bmod p=\\prod_{j=0}^{k-1} K_{i,j}^{l^j} \\bmod p\\) Guardian \\(T_l\\) selects a random value \\(u_{i,l}\\) in \\(Z_q\\) and commits to the pair \\[ \\left(a_{i,l},b_{i,l} \\right)=\\left(g^{u_{i,l} } \\bmod p,A^{u_{i,l}} \\bmod p\\right) \\] The values \\((A,B)\\) , \\((a_{i,l},b_{i,l} )\\) , and \\(M_(i,l)\\) are hashed together with the extended base hash value \\(\\bar{Q}\\) to form a challenge value \\[ c_{i,l}=H\\left(\\bar{Q},(A,B),(a_{i,l},b_{i,l} ),M_{i,l} \\right) \\] and guardian \\(T_l\\) responds with \\[ v_{i,l}=\\left(u_{i,l}+c_{i,l} P_i (l)\\right) \\bmod q \\] It is important to note here that although the value \\(P_i (l)\\) is known to both the missing guardian \\(T_i\\) and the guardian \\(T_l\\) , it need not published or generally known. However, the value \\[ g^{P_i (l)} \\bmod p \\] can be computed from public values as \\[ g^{P_i (l)} \\bmod p=\\prod_{j=0}^{k-1} K_{i,j}^{l^j} \\bmod p. \\] Important An election verifier must confirm the following for each (non-placeholder) option in each contest in the ballot coding file the following for each missing guardian \\(T_i\\) and for each surrogate guardian \\(T_l\\) . (A) The given value \\(v_{i,l}\\) is in the set \\(Z_q\\) . (B) The given values \\(a_{i,l}\\) and \\(b_{i,l}\\) are both in the set \\(Z_q^r\\) . (C) The challenge value \\(c_{i,l}\\) satisfies \\[ c_{i,l}=H\\left(\\bar{Q},(A,B),(a_{i,l},b_{i,l} ),M_{i,l} \\right) \\] (D) The equation \\[ g^{v_{i,l}} \\bmod p=\\left(a_{i,l}\\cdot \\left(\\prod_{j=0}^{k-1} K_{i,j}^{l^j} \\right)^{c_{i,l}} \\right) \\bmod p \\] is satisfied. (E) The equation \\[ A^{v_{i,l}} \\bmod p=\\left(b_{i,l} M_{i,l}^{c_{i,l} } \\right) \\bmod p \\] is satisfied. The final step to reconstruct a missing partial decryption \\(M_i\\) is to compute Lagrange coefficients for a set of \\(k\\) available guardians \\({T_l \\colon l \\in U}\\) with \\(|U|=k\\) as \\[ w_l=\\frac{(\\prod_{j \\in (U-{l})} j)}{\\left(\\prod_{j \\in (U-{l})}(j-l) \\right) } \\bmod q. \\] Important An election verifier should confirm that for each guardian \\(T_l\\) serving to help compute a missing share of a tally, that its Lagrange coefficient \\(w_l\\) is correctly computed by confirming the folloing equation \\[ \\left(\\prod_{j \\in (U-\\{\\ell \\})}j\\right) \\bmod q=\\left(w_\\ell \\cdot \\left(\\prod_{j \\in (U-\\{\\ell \\})} \\left(j-\\ell \\right) \\right) \\right) \\bmod q \\] An election verifier should then confirm the correct missing tally share for each (non-placeholder) option in each contest in the ballot coding file for each missing guardian \\(T_i\\) as \\[ M_i=\\prod_{\\ell \\in U}\\left(M_{i,\\ell }\\right)^{w_\\ell} \\bmod p \\] Note The missing secret \\(s_i\\) could be computed directly via the equation below. However, it is preferable to not release the missing secret and instead only release the partial decryption that the missing secret would have produced. This prevents the missing secret \\(s_i\\) from being used for additional decryptions without the cooperation of at least \\(k\\) guardians. \\[ s_i=\\sum_{\\ell \\in U} w_\\ell P_i(\\ell) \\bmod q \\] As an example, consider an election with five guardians and a threshold of three. If two guardians are missing at the time of decryption, the remaining three can perform any required decryptions by constructing missing partial descriptions as described in the text above. If, instead, they take the shortcut of simply reconstructing and then using the two missing secrets, then any of the three could, at a later time, use its own secret together with the two reconstructed secrets to perform additional decryptions without cooperation of any other guardian . The final step is to verify the tallies themselves. Important An election verifier should confirm the following equations for each (non-placeholder) option in each contest in the ballot coding file. (A) \\[ B=\\left(M\u22c5\\left(\\prod_{i=1}^n M_i \\right)\\right) \\bmod p \\] (B) \\[ M=g^t \\bmod p. \\] An election verifier should also confirm that the text labels listed in the election record match the corresponding text labels in the ballot coding file. Decryption of Spoiled Ballots Every ballot spoiled in an election is individually verifiably decrypted in exactly the same way that the aggregate ballot of tallies is decrypted. Election verifiers should confirm all such decryptions so that casual observers can simply view the decryptions and confirm that they match their expectations. Important An election verifier should confirm the correct decryption of each spoiled ballot using the same process that was used to confirm the election tallies. An election verifier should also confirm that for each decrypted spoiled ballot, the selections listed in text match the corresponding text in the ballot coding file.","title":"Verifiable Decryption"},{"location":"spec/0.95.0/7_Verifiable_decryption/#verifiable-decryption","text":"","title":"Verifiable Decryption"},{"location":"spec/0.95.0/7_Verifiable_decryption/#discussion","text":"To decrypt an aggregate encryption \\((A,B)\\) (or an individual encryption such as one on a spoiled ballot), each available election guardian \\(T_i\\) uses its secret key \\(s_i\\) to compute its share of the decryption as \\[ M_i=A^{s_i} \\bmod p \\] Each guardian \\(T_i\\) also publishes a Chaum-Pedersen proof of the correctness of \\(M_i\\) as follows.","title":"Discussion"},{"location":"spec/0.95.0/7_Verifiable_decryption/#nizk-proof-by-guardian-t_i-of-knowledge-of-s_i-in-z_pr-for-which-both-m_ias_i-bmod-p-and-k_igs_i-bmod-p","text":"Guardian \\(T_i\\) selects a random value \\(u_i\\) in \\(Z_q\\) and commits to the pair \\[ (a_i,b_i )=\\left(g^{u_i} \\bmod p,A^{u_i} \\bmod p\\right) \\] The values \\((A,B)\\) , \\((a_i,b_i )\\) , and \\(M_i\\) are hashed together with the extended base hash value \\(\\bar{Q}\\) to form a challenge value \\[ c_i=H\\left(\\bar{Q},(A,B),(a_i,b_i ),M_i \\right) \\] and guardian T_i responds with \\[ v_i=(u_i+c_i s_i ) \\bmod q \\] Important An election verifier must then confirm for each (non-placeholder) option in each contest in the ballot coding file the following for each decrypting guardian \\(T_i\\) . (A) The given value \\(v_i\\) is in the set \\(Z_q\\) . (B) The given values \\(a_i\\) and \\(b_i\\) are both in the set \\(Z_q^r\\) . (C) The challenge value \\(c_i\\) satisfies \\[ c_i=H\\left(\\bar{Q},(A,B),(a_i,b_i ),M_i \\right) \\] (D) The equation \\[ g^(v_i ) mod p=(a_i K_i^{c_i} ) \\bmod p \\] is satisfied. (E) The equation \\[ A^{v_i} \\bmod p=(b_i M_i^{c_i} ) \\bmod p \\] is satisfied.","title":"NIZK Proof by Guardian \\(T_i\\) of knowledge of \\(s_i \\in Z_p^r\\) for which both \\(M_i=A^{s_i} \\bmod p\\) and \\(K_i=g^{s_i}  \\bmod p\\)"},{"location":"spec/0.95.0/7_Verifiable_decryption/#decryption-when-all-guardians-are-present","text":"If all guardians are present and have posted suitable proofs, the next step is to publish the value \\[ M=\\frac{B}{\\left(\\prod_{i=1}^n{M_i}\\right)} \\bmod p \\] This \\(M\\) has the property that \\(M=g^t \\bmod p\\) where \\(t\\) is the tally of the associated option. In general, computation of this tally value t is computationally intractable. However, in this application, t is relatively small \u2013 bounded by the number of votes cast. Election administrators can determine this tally value t from M by exhaustive search, by precomputing a table of all possible M values in the allowable range and then performing a single look-up, or by a combination in which some exponentiations are precomputed and a small search is used to find the value of t (e.g., a partial table consisting of g^100 mod p, g^200 mod p, g^300 mod p, \u2026 is precomputed and the value M is repeatedly divided by g until a value is found that is in the partial table). The value t is published in the election record, and verifiers should check both that M=g^t mod p and that \\[ B= \\left(M\u22c5\\prod_{i=1}^n M_i \\right) \\bmod p \\]","title":"Decryption when all guardians are present"},{"location":"spec/0.95.0/7_Verifiable_decryption/#decryption-with-missing-guardians","text":"If one or more of the election guardians are not available for decryption, any k available guardians can use the information they have to reconstruct the partial decryptions for missing guardians as follows. If guardian \\(T_i\\) is missing during decryption, each of at least \\(k\\) available guardians \\(T_l\\) should use its share \\(P_i (l)\\) of the secret value \\(s_i\\) previously shared by \\(T_i\\) to compute a share of the missing partial decryption \\(M_i\\) in the same way that it used its own secret \\(s_l\\) . Specifically, guardian \\(T_l\\) publishes partial decryption share \\[ M_{i,l}=A^{P_i (l)} \\bmod p \\] Guardian \\(T_l\\) also publishes a Chaum-Pedersen proof of the correctness of \\(M_(i,l)\\) as follows.","title":"Decryption with missing guardians"},{"location":"spec/0.95.0/7_Verifiable_decryption/#nizk-proof-by-guardian-t_l-of-knowledge-of-s_il-in-z_pr-for-which-both-m_ilas_il-bmod-p-and-gs_i-bmod-pprod_j0k-1-k_ijlj-bmod-p","text":"Guardian \\(T_l\\) selects a random value \\(u_{i,l}\\) in \\(Z_q\\) and commits to the pair \\[ \\left(a_{i,l},b_{i,l} \\right)=\\left(g^{u_{i,l} } \\bmod p,A^{u_{i,l}} \\bmod p\\right) \\] The values \\((A,B)\\) , \\((a_{i,l},b_{i,l} )\\) , and \\(M_(i,l)\\) are hashed together with the extended base hash value \\(\\bar{Q}\\) to form a challenge value \\[ c_{i,l}=H\\left(\\bar{Q},(A,B),(a_{i,l},b_{i,l} ),M_{i,l} \\right) \\] and guardian \\(T_l\\) responds with \\[ v_{i,l}=\\left(u_{i,l}+c_{i,l} P_i (l)\\right) \\bmod q \\] It is important to note here that although the value \\(P_i (l)\\) is known to both the missing guardian \\(T_i\\) and the guardian \\(T_l\\) , it need not published or generally known. However, the value \\[ g^{P_i (l)} \\bmod p \\] can be computed from public values as \\[ g^{P_i (l)} \\bmod p=\\prod_{j=0}^{k-1} K_{i,j}^{l^j} \\bmod p. \\] Important An election verifier must confirm the following for each (non-placeholder) option in each contest in the ballot coding file the following for each missing guardian \\(T_i\\) and for each surrogate guardian \\(T_l\\) . (A) The given value \\(v_{i,l}\\) is in the set \\(Z_q\\) . (B) The given values \\(a_{i,l}\\) and \\(b_{i,l}\\) are both in the set \\(Z_q^r\\) . (C) The challenge value \\(c_{i,l}\\) satisfies \\[ c_{i,l}=H\\left(\\bar{Q},(A,B),(a_{i,l},b_{i,l} ),M_{i,l} \\right) \\] (D) The equation \\[ g^{v_{i,l}} \\bmod p=\\left(a_{i,l}\\cdot \\left(\\prod_{j=0}^{k-1} K_{i,j}^{l^j} \\right)^{c_{i,l}} \\right) \\bmod p \\] is satisfied. (E) The equation \\[ A^{v_{i,l}} \\bmod p=\\left(b_{i,l} M_{i,l}^{c_{i,l} } \\right) \\bmod p \\] is satisfied. The final step to reconstruct a missing partial decryption \\(M_i\\) is to compute Lagrange coefficients for a set of \\(k\\) available guardians \\({T_l \\colon l \\in U}\\) with \\(|U|=k\\) as \\[ w_l=\\frac{(\\prod_{j \\in (U-{l})} j)}{\\left(\\prod_{j \\in (U-{l})}(j-l) \\right) } \\bmod q. \\] Important An election verifier should confirm that for each guardian \\(T_l\\) serving to help compute a missing share of a tally, that its Lagrange coefficient \\(w_l\\) is correctly computed by confirming the folloing equation \\[ \\left(\\prod_{j \\in (U-\\{\\ell \\})}j\\right) \\bmod q=\\left(w_\\ell \\cdot \\left(\\prod_{j \\in (U-\\{\\ell \\})} \\left(j-\\ell \\right) \\right) \\right) \\bmod q \\] An election verifier should then confirm the correct missing tally share for each (non-placeholder) option in each contest in the ballot coding file for each missing guardian \\(T_i\\) as \\[ M_i=\\prod_{\\ell \\in U}\\left(M_{i,\\ell }\\right)^{w_\\ell} \\bmod p \\] Note The missing secret \\(s_i\\) could be computed directly via the equation below. However, it is preferable to not release the missing secret and instead only release the partial decryption that the missing secret would have produced. This prevents the missing secret \\(s_i\\) from being used for additional decryptions without the cooperation of at least \\(k\\) guardians. \\[ s_i=\\sum_{\\ell \\in U} w_\\ell P_i(\\ell) \\bmod q \\] As an example, consider an election with five guardians and a threshold of three. If two guardians are missing at the time of decryption, the remaining three can perform any required decryptions by constructing missing partial descriptions as described in the text above. If, instead, they take the shortcut of simply reconstructing and then using the two missing secrets, then any of the three could, at a later time, use its own secret together with the two reconstructed secrets to perform additional decryptions without cooperation of any other guardian . The final step is to verify the tallies themselves. Important An election verifier should confirm the following equations for each (non-placeholder) option in each contest in the ballot coding file. (A) \\[ B=\\left(M\u22c5\\left(\\prod_{i=1}^n M_i \\right)\\right) \\bmod p \\] (B) \\[ M=g^t \\bmod p. \\] An election verifier should also confirm that the text labels listed in the election record match the corresponding text labels in the ballot coding file.","title":"NIZK Proof by Guardian \\(T_l\\) of knowledge of \\(s_{i,l} \\in Z_p^r\\) for which both \\(M_{i,l}=A^{s_{i,l}}  \\bmod p\\) and \\(g^{s_i} \\bmod p=\\prod_{j=0}^{k-1} K_{i,j}^{l^j}   \\bmod p\\)"},{"location":"spec/0.95.0/7_Verifiable_decryption/#decryption-of-spoiled-ballots","text":"Every ballot spoiled in an election is individually verifiably decrypted in exactly the same way that the aggregate ballot of tallies is decrypted. Election verifiers should confirm all such decryptions so that casual observers can simply view the decryptions and confirm that they match their expectations. Important An election verifier should confirm the correct decryption of each spoiled ballot using the same process that was used to confirm the election tallies. An election verifier should also confirm that for each decrypted spoiled ballot, the selections listed in text match the corresponding text in the ballot coding file.","title":"Decryption of Spoiled Ballots"},{"location":"spec/0.95.0/8_The_election_record/","text":"The Election Record The record of an election should be a full accounting of all of the election artifacts. Specifically, it should contain the following: Date and location of an election The ballot coding file The baseline parameters Primes \\(p\\) and \\(q\\) and integer \\(r\\) such that \\(p=qr+1\\) and \\(r\\) is not a multiple of \\(q\\) A generator \\(g\\) of the order \\(q\\) multiplicative subgroup \\(Z_p^*\\) The number \\(n\\) of election guardians The quorum threshold \\(k\\) of guardians required to complete verification The base hash value \\(Q\\) computed from the above The commitments from each election guardian to each of their polynomial coefficients The proofs from each guardian of possession of each of the associated coefficients The election public key The extended base hash value \\(\\bar{Q}\\) computed from the above Every encrypted ballot prepared in the election (whether cast or spoiled) All of the encrypted options on each ballot (including \u201cplaceholder\u201d options) The proofs that each such value is an encryption of either zero or one The selection limit for each contest The proof that the number of selections made matches the selection limit The device information for the device that encrypted the ballot The date and time of the ballot encryption The tracker code produced for the ballot The decryption of each spoiled ballot The selections made on the ballot The cleartext representation of the selections Partial decryptions by each guardian of each option Proofs of each partial decryption Shares of each missing partial decryption (if any) Proofs of shares of each missing partial decryption (if any) Lagrange coefficients used for replacement of any missing partial decryptions (if any) Tallies of each option in an election The encrypted tally of each option Full decryptions of each encrypted tally Cleartext representations of each tally Partial decryptions by each guardian of each tally Proofs of partial decryption of each tally Shares of each missing partial decryption (if any) Proofs of shares of each missing partial decryption (if any) Lagrange coefficients used for replacement of any missing partial decryptions (if any) Ordered lists of the ballots encrypted by each device An election record should be digitally signed by election administrators together with the date of the signature. The entire election record and its digital signature should be published and made available for full download by any interested individuals. Tools should also be provided for easy look up of tracking codes by voters.","title":"The Election Record"},{"location":"spec/0.95.0/8_The_election_record/#the-election-record","text":"The record of an election should be a full accounting of all of the election artifacts. Specifically, it should contain the following: Date and location of an election The ballot coding file The baseline parameters Primes \\(p\\) and \\(q\\) and integer \\(r\\) such that \\(p=qr+1\\) and \\(r\\) is not a multiple of \\(q\\) A generator \\(g\\) of the order \\(q\\) multiplicative subgroup \\(Z_p^*\\) The number \\(n\\) of election guardians The quorum threshold \\(k\\) of guardians required to complete verification The base hash value \\(Q\\) computed from the above The commitments from each election guardian to each of their polynomial coefficients The proofs from each guardian of possession of each of the associated coefficients The election public key The extended base hash value \\(\\bar{Q}\\) computed from the above Every encrypted ballot prepared in the election (whether cast or spoiled) All of the encrypted options on each ballot (including \u201cplaceholder\u201d options) The proofs that each such value is an encryption of either zero or one The selection limit for each contest The proof that the number of selections made matches the selection limit The device information for the device that encrypted the ballot The date and time of the ballot encryption The tracker code produced for the ballot The decryption of each spoiled ballot The selections made on the ballot The cleartext representation of the selections Partial decryptions by each guardian of each option Proofs of each partial decryption Shares of each missing partial decryption (if any) Proofs of shares of each missing partial decryption (if any) Lagrange coefficients used for replacement of any missing partial decryptions (if any) Tallies of each option in an election The encrypted tally of each option Full decryptions of each encrypted tally Cleartext representations of each tally Partial decryptions by each guardian of each tally Proofs of partial decryption of each tally Shares of each missing partial decryption (if any) Proofs of shares of each missing partial decryption (if any) Lagrange coefficients used for replacement of any missing partial decryptions (if any) Ordered lists of the ballots encrypted by each device An election record should be digitally signed by election administrators together with the date of the signature. The entire election record and its digital signature should be published and made available for full download by any interested individuals. Tools should also be provided for easy look up of tracking codes by voters.","title":"The Election Record"},{"location":"spec/0.95.0/9_Verifier_construction/","text":"Verifier Construction While it is desirable for anyone who may construct an ElectionGuard verifier to have as complete understanding as possible of the ElectionGuard design, this section isolates the items which must be verified and maps the variables used in the specification equations herein to the labels provided in the artifacts produced in an election. 1 Implementation details There are four operations which must be performed \u2013 all on very large integer values: modular addition, modular multiplication, modular exponentiation, and SHA-256 hash computations. These operations can be performed using a programming language that provides native support, by importing tools to perform these large integer operations, or by implementing these operations from scratch. Modular Addition To compute \\[ (a+b) \\bmod n \\] one can compute \\[ ((a \\bmod n)+(b \\bmod n)) \\bmod n \\] However, this is rarely beneficial. If it is known that \\(a,b \\in Z_n\\) , then one can choose to avoid the division normally inherent in the modular reduction and just use \\[ (a+b) \\bmod n=a+b \\] (if \\(a+b \\lt n\\) ) or \\[ a+b-n \\] (if \\(a+b \\ge n\\) ). Modular Multiplication To compute \\[ (a \\times b) \\bmod n \\] one can compute \\[ ((a \\bmod n) \\times(b \\bmod n)) \\bmod n \\] Unless it is already known that \\(a,b \\in Z_n\\) , it is usually beneficial to perform modular reduction on these intermediate values before computing the product. However, it is still necessary to perform modular reduction on the result of the multiplication. Modular Exponentiation To compute \\[ a^b \\bmod n \\] one can compute \\[ (a \\bmod n)^b \\bmod n \\] but one should not perform a modular reduction on the exponent. 2 One should, however, never simply attempt to compute the exponentiation \\(a^b\\) before performing a modular reduction as the number \\(a^b\\) would likely contain more digits then there are particles in the universe. Instead, one should use a special-purpose modular exponentiation method such as repeated squaring which prevents intermediate values from growing excessively large. Some languages include a native modular exponentiation primitive, but when this is not available a specialized modular exponentiation tool can be imported or written from scratch. Hash Computation Hashes are computed using the SHA-256 hash function in NIST (2015) Secure Hash Standard (SHS) which is published in FIPS 180-4 and can be found in https://csrc.nist.gov/publications/detail/fips/180/4/final . For the purposes of SHA-256 hash computations, all inputs \u2013 whether textural or numeric \u2013 are represented as utf-8 encoded strings. Numbers are represented as strings in base ten. The hash function expects a single-dimensional array of input elements that are hashed iteratively, rather than concatenated together. Each element in the hash is separated by the pipe character (\u201c|\u201d). When dealing with multi-dimensional arrays, the elements are hashed recursively in the order in which they are input into the hash function. For instance, calling \\[ H(1,2,[3,4,5],6) \\] is a function call with 4 parameters, where the 3rd parameter is itself an array. The hash function will process arguments 1 and 2, when it gets to argument 3 it will traverse the array (and hash the values 3, 4 ,5) before hashing the final fourth argument (whose value is 6). When hashing an array element that is empty, the array is instead replaced with the word \u201cnull\u201d as a placeholder. Parameter Validation Important An ElectionGuard version 1 election verifier may assume that the baseline parameters match the parameters provided above. However, it is recommended that the below parameters be checked against the parameters of each election to accommodate the possibility of different parameters in future versions of ElectionGuard . 3 Variable Meaning Folder File Level \\(p\\) 4096-bit modulus root constants.json large_prime \\(q\\) 256-bit prime order of subgroup \\(Z_p^*\\) of encryptions root constants.json small_prime \\(r\\) co-factor of \\(q\\) root constants.json cofactor \\(g\\) generator of order \\(q\\) multiplicative subgroup of \\(Z_p^*\\) root contstants.json generator \\(n\\) number of guardians root context.json number_of_guardians \\(k\\) minimum number of guardians required to decrypt tallies and produce verification data root context.json quorum \\(Q\\) base hash value formed by \\(p\\) , \\(q\\) , \\(g\\) , \\(n\\) , \\(k\\) , date, and jurisdictional information root context.json crypto_base_hash Guardian Public Key Validation Important An election verifier must confirm the following for each guardian \\(T_i\\) and for each \\(j \\in Z_k\\) : (A) The challenge \\(c_{i,j}\\) is correctly computed as \\[ c_{i,j}=H(Q,K_{i,j},h_{i,j} ) \\bmod q \\] (B) The equation \\[ g^{u_{i,j} } \\bmod p=h_{i,j} K_{i,j}^{c_{i,j} } \\bmod p \\] is satisfied. Variable Meaning Folder File Level \\(K_{i,j}\\) public form of each random coefficient \\(a_{i,j}\\) coefficients every file in this folder large_prime \\(h_(i,j)\\) coefficient commitments coefficients every file in this folder coefficient_proofs \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) commitment \\(c_i\\) challenge value coefficients every file in this folder coefficient_proofs \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) challenge \\(u_{i,j}\\) response coefficients every file in this folder coefficient_proofs \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) response Election Public Key Validation Important An election verifier must verify the correct computation of the joint election public key and extended base hash. (A) Joint election public key \\[ K=\\prod_{i=1}^n K_i \\bmod p \\] (B) Extended base hash \\[ \\bar{Q} = H(Q,K_1,0,K_1,1,K_1,2,\\ldots,K_{1,k-1},K_2,0,K_2,1,K_2,2,\\ldots,K_{2,k-1},\\ldots,K_{n,0},K_{n,1},K_{n,2},\\ldots,K_{n,k-1}) \\] Variable Meaning Folder File Level \\(\\bar{Q}\\) extended base hash Root context.json crypto_extended_base_hash \\(K\\) joint election public key Root context.json elgamal_public_key Correctness of Selection Encryptions Important An election verifier must confirm the following for each possible selection on a ballot: The given values \\(\\alpha\\) , \\(\\beta\\) , \\(a_0\\) , \\(b_0\\) , \\(a_1\\) , and \\(b_1\\) are all in the set \\(Z_p^r\\) . (A value \\(x\\) is in \\(Z_p^r\\) if and only if \\(x\\) is an integer such that \\(0 \\le x \\lt p\\) and \\(x^q \\bmod p=1\\) is satisfied.) (J) The challenge \\(c\\) is correctly computed as \\[ c=H(\\bar{Q},(\\alpha,\\beta),(a_0,b_0 ),(a_1,b_1 )) \\] (K) The given values \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) are each in the set \\(Z_q\\) . (A value \\(x\\) is in \\(Z_q\\) if and only if \\(x\\) is an integer such that 0 \\le x \\lt q.) (L) The equation \\[ c=(c_0+c_1 ) \\bmod q \\] is satisfied. (M) The equation \\[ g^{v_0} \\bmod p= a_0 \\alpha^{c_0} \\bmod p \\] is satisfied. (N) The equation \\[ g^{v_1} \\bmod p=a_1 \\alpha^{c_1} \\bmod p \\] is satisfied. (O) The equation \\[ K^{v_0} \\bmod p=b_0 \\beta^{c_0} \\bmod p \\] is satisfied. (P) The equation \\[ g^{c_1} K^{v_1} \\bmod p=b_1 \\beta^{c_1} \\bmod p \\] is satisfied. Variable Meaning Folder File Level \\((\\alpha,\\beta)\\) encryption of vote encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ciphertext \\(\\rightarrow\\) pad, data (a_0,b_0) commitment to vote being an encryption of zero encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_zero_pad, proof_zero_data \\((a_1,b_1)\\) commitment to vote being an encryption of one encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_one_pad, proof_one_data \\(c\\) challenge encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_challenge \\(c_0\\) derived challenge to encryption of zero encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_zero_challenge \\(c_1\\) derived challenge to encryption of one encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_one_challenge \\(v_0\\) response to zero challenge encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_zero_response \\(v_1\\) response to one challenge encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_one_response Adherence to Vote Limits Important An election verifier must confirm the following for each contest on the ballot: (H) The number of placeholder positions matches the contest\u2019s selection limit \\(L\\) . (I) The contest total \\((A,B)\\) satisfies \\[ A=\\prod_i \\alpha_i \\bmod p \\] and \\[ B=\\prod_i \\beta_i \\bmod p \\] where the \\((\\alpha_i,\\beta_i )\\) represent all possible selections (including placeholder selections) for the contest. (J) The given value \\(V\\) is in \\(Z_q\\) . (K) The given values a and b are each in \\(Z_p^r\\) . (L) The challenge value \\(C\\) is correctly computed as \\[ C=H(\\bar{Q},(A,B),(a,b)) \\] (M) The equation \\[ g^V \\bmod p=(aA^C ) \\bmod p \\] is satisfied. (N) The equation \\[ ((g^{LC} K)^V ) \\bmod p=(bB^C ) \\bmod p \\] is satisfied. Variable Meaning Folder File Level \\((\\alpha_i,\\beta_i)\\) encryption of \\(i^th\\) vote in contest encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ciphertext \\(\\rightarrow\\) pad, data \\((A,B)\\) encryption of total votes in contest encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) total \\(\\rightarrow\\) pad, data \\((a,b)\\) commitment to vote being an encryption of one encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) total \\(\\rightarrow\\) proof \\(\\rightarrow\\) pad, data \\(C\\) selection limit challenge encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) challenge \\(L\\) contest selection limit root description.json contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) votes_allowed \\(V\\) response to selection limit challenge encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) response Validation of Ballot Chaining Important An election verifier must confirm that each of the values in the running hash is correctly computed. Specifically, an election verifier must confirm each of the following. (D) The equation \\(H_0=H(\\bar{Q})\\) is satisfied. (E) For each ballot \\[ B_i, H_i=H(H_{i-1},D,T,B_i) \\] is satisfied. (F) The closing hash \\[ \\bar{H} =H(H_l,\\text{\u201cCLOSE\"}) \\] is correctly computed from the final tracking code \\(H_l\\) . Variable Meaning Folder File Level \\(H_i\\) running hash of ballots produced encrypted_ballots every file in this folder tracking_hash (also previous_tracking_hash) Correctness of Ballot Aggregation Important An election verifier must confirm for each (non-placeholder) option in each contest in the ballot coding file that the aggregate encryption \\((A,B)\\) satisfies \\[ A=\\prod_j\\alpha_j \\] and \\[ \\beta=\\prod_j \\beta_j \\] where the \\((\\alpha_j,\\beta_j )\\) are the corresponding encryptions on all cast ballots in the election record. Variable Meaning Folder File Level \\((\\alpha_j,\\beta_j)\\) encryption of vote encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ciphertext \\(\\rightarrow\\) pad, data \\((A,B)\\) encrypted aggregate total of votes in contest root tally.json [prefix] \\(\\rightarrow\\) message \\(\\rightarrow\\) pad, data Correctness of Partial Decryptions Important An election verifier must then confirm for each (non-placeholder) option in each contest in the ballot coding file the following for each decrypting trustee \\(T_i\\) . The given value \\(v_i\\) is in the set \\(Z_q\\) . The given values \\(a_i\\) and \\(b_i\\) are both in the set \\(Z_q^r\\) . The challenge value \\(c_i\\) satisfies \\[ c_i=H(\\bar{Q},(A,B),(a_i,b_i ),M_i ) \\] The equation \\[ g^{v_i} \\bmod p=(a_i K_i^{c_i} ) \\bmod p \\] is satisfied. The equation \\(A^{v_i} \\bmod p=(b_i M_i^{c_i} ) \\bmod p\\) is satisfied. Correctness of Partial Decryptions Important An election verifier must then confirm for each (non-placeholder) option in each contest in the ballot coding file the following for each decrypting trustee \\(T_i\\) . (F) The given value \\(v_i\\) is in the set of \\(Z_q\\) (G) The given values \\(a_i\\) and \\(b_i\\) are both in the set \\(Z_q^r\\) . (H) The challenge value \\(c_i\\) satisfies \\[ c_i=H(Q \u0305,(A,B),(a_i,b_i ),M_i ) \\] (I) The equation \\[ g^{v_i} \\bmod p=(a_i K_i^{c_i} ) \\bmod p \\] is satisfied. (J) The equation \\[ A^{v_i} \\bmod p=(b_i M_i^{c_i} ) \\bmod p \\] is satisfied. Variable Meaning Folder File Level \\((A,B)\\) encrypted aggregate total of votes in contest root tally.json [prefix] \\(\\rightarrow\\) message \\(\\rightarrow\\) pad, data \\(M_i\\) partial decryption of \\((A,B)\\) by guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) share \\((a_i,b_i)\\) commitment by guardian \\(T_i\\) to partial decryption of \\((A,B)\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) pad, data \\(c_i\\) challenge to partial decryption of guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) challenge \\(v_i\\) response to challenge of guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) response Correctness of Substitute Data for Missing Guardians Note This is only necessary if some guardians are missing during tallying Important An election verifier must confirm for each (non-placeholder) option in each contest in the ballot coding file the following for each missing trustee \\(T_i\\) and for each surrogate trustee \\(T_\\ell\\) . (A) The given value \\(v_{i,l}\\) is in the set \\(Z_q\\) . (B) The given values \\(a_{i,l}\\) and \\(b_{i,l}\\) are both in the set \\(Z_q^r\\) . (C) The challenge value \\(c_{i,l}\\) satisfies \\[ c_(i,l)=H(Q \u0305,(A,B),(a_(i,l),b_(i,l) ),M_(i,l) ) \\] (D) The equation \\[ g^{v_{i,l}} \\bmod p=\\left(a_{i,l}\\cdot \\left(\\prod_{j=0}^{k-1} K_{i,j}^{l^j} \\right)^{c_{i,l} } \\right) \\bmod p \\] is satisfied. (E) The equation \\[ A^{v_{i,\\ell}} \\bmod p= \\left( b_{i,\\ell} M_{i,l}^{c_{i,l}} \\right) \\bmod p \\] is satisfied. Variable Meaning Folder File Level \\((A,B)\\) encrypted aggregate total of votes in contest root tally.json [prefix] \\(\\rightarrow\\) message \\(\\rightarrow\\) pad, data \\(M_(i,\\ell)\\) share of guardian \\(T_\\ell\\) of missing partial decryption of \\((A,B)\\) by guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) substitute_proof \\(\\rightarrow\\) [item] \\(\\rightarrow\\) share \\((a_{i,l},b_{i,l})\\) commitment by guardian \\(T_\\ell\\) to share of partial decryption for missing guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) substitute_proof \\(\\rightarrow\\) [item] \\(\\rightarrow\\) pad, data \\(c_{i,\\ell}\\) challenge to guardian \\(T_\\ell\\) share of missing partial decryption of guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) substitute_proof \\(\\rightarrow\\) [item] \\(\\rightarrow\\) challenge \\(v_{i,l}\\) response to challenge of guardian \\(T_\\ell\\) share of partial decryption of guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) substitute_proof \\(\\rightarrow\\) [item] \\(\\rightarrow\\) response Correctness of Construction of Replacement Partial Decryptions Note This is only necessary if some guardians are missing during tallying Important An election verifier should confirm that for each trustee \\(T_\\ell\\) serving to help compute a missing share of a tally, that its Lagrange coefficient \\(w_\\ell\\) is correctly computed by confirming the equation \\[ \\left(\\prod_{j\\in(U-{\\ell})}j\\right) \\bmod q=\\left(w_l\u22c5\\left(\\prod_{j\\in (U-{l})} (j-\\ell) \\right)\\right) \\bmod q \\] An election verifier should then confirm the correct missing tally share for each (non-placeholder) option in each contest in the ballot coding file for each missing trustee \\(T_i\\) as \\[ M_i=\\prod_{\\ell \\in U}\\left(M_{i,\\ell}\\right)^{w_\\ell} \\bmod p \\] Variable Meaning Folder File Level \\(w_\\ell\\) coefficient for use with shares of guardian \\(T_\\ell\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [item] \\(\\rightarrow\\) coefficient \\(M_{i,\\ell}\\) share of guardian \\(T_\\ell\\) of missing partial decryption of \\((A,B)\\) by guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) substitute_proof \\(\\rightarrow\\) [item] \\(\\rightarrow\\) share \\(M_i\\) partial decryption of \\((A,B)\\) by guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) share Validation of Correct Decryption of Tallies Important An election verifier should confirm the following equations for each (non-placeholder) option in each contest in the ballot coding file. (C) \\[ B=\\left(M \\cdot \\left(\\prod_{i=1}^n M_i \\right)\\right) \\bmod p \\] (D) \\[ M=g^t \\bmod p \\] An election verifier should also confirm that the text labels listed in the election record match the corresponding text labels in the ballot coding file. Variable Meaning Folder File Level \\(M_i\\) partial decryption of \\((A,B)\\) by guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) share (M) full decryption of \\((A,B)\\) root tally.json [prefix] \\(\\rightarrow\\) value \\(t\\) tally value root tally.json [prefix] \\(\\rightarrow\\) tally Validation of Correct Decryption of Spoiled Ballots Important An election verifier should confirm the correct decryption of each spoiled ballot using the same process that was used to confirm the election tallies. An election verifier should also confirm that for each decrypted spoiled ballot, the selections listed in text match the corresponding text in the ballot coding file. Validation of Correct Decryption of Spoiled Ballots is a repeat of verification steps 8 through 11 for each spoiled ballot instead of for the aggregate ballot that contains encrypted tallies Special thanks to Rainbow Huang (@rainbowhuanguw) for her help in producing this mapping. \u21a9 In general, if \\(n\\) is prime, one can compute \\(a^b \\bmod n\\) as \\((a \\bmod n)^{(b \\bmod (n-1)} ) \\bmod n\\) . But within this application, the efficiency benefits of performing a modular reduction on an exponent are limited, and the risk of confusion or error from doing so likely exceeds the benefit. In the particular instance of this specification, if \\(a \\in Z_p^r\\) , then one can compute \\(a^b \\bmod p\\) as \\(a^{(b mod q)} \\bmod p\\) . This has greater efficiency benefits, but the risk of confusion or error still likely exceed the efficiency benefit. \u21a9 If alternative parameters are allowed, election verifiers must confirm that \\(p\\) , \\(q\\) , \\(r\\) , \\(g\\) , and $\\bar{g} are such that both \\(p\\) and \\(q\\) are prime (this may be done probabilistically using the Miller-Rabin algorithm), that \\(p-1=qr\\) is satisfied, that \\(q\\) is not a divisor of \\(r\\) , and \\(1 \\lt g \\lt p\\) , that \\(g^q \\bmod p=1\\) , that \\(g \\bar{g} \\bmod p=1\\) , and that generation of the parameters is consistent with the cited standard. \u21a9","title":"Verifier Construction"},{"location":"spec/0.95.0/9_Verifier_construction/#verifier-construction","text":"While it is desirable for anyone who may construct an ElectionGuard verifier to have as complete understanding as possible of the ElectionGuard design, this section isolates the items which must be verified and maps the variables used in the specification equations herein to the labels provided in the artifacts produced in an election. 1","title":"Verifier Construction"},{"location":"spec/0.95.0/9_Verifier_construction/#implementation-details","text":"There are four operations which must be performed \u2013 all on very large integer values: modular addition, modular multiplication, modular exponentiation, and SHA-256 hash computations. These operations can be performed using a programming language that provides native support, by importing tools to perform these large integer operations, or by implementing these operations from scratch.","title":"Implementation details"},{"location":"spec/0.95.0/9_Verifier_construction/#modular-addition","text":"To compute \\[ (a+b) \\bmod n \\] one can compute \\[ ((a \\bmod n)+(b \\bmod n)) \\bmod n \\] However, this is rarely beneficial. If it is known that \\(a,b \\in Z_n\\) , then one can choose to avoid the division normally inherent in the modular reduction and just use \\[ (a+b) \\bmod n=a+b \\] (if \\(a+b \\lt n\\) ) or \\[ a+b-n \\] (if \\(a+b \\ge n\\) ).","title":"Modular Addition"},{"location":"spec/0.95.0/9_Verifier_construction/#modular-multiplication","text":"To compute \\[ (a \\times b) \\bmod n \\] one can compute \\[ ((a \\bmod n) \\times(b \\bmod n)) \\bmod n \\] Unless it is already known that \\(a,b \\in Z_n\\) , it is usually beneficial to perform modular reduction on these intermediate values before computing the product. However, it is still necessary to perform modular reduction on the result of the multiplication.","title":"Modular Multiplication"},{"location":"spec/0.95.0/9_Verifier_construction/#modular-exponentiation","text":"To compute \\[ a^b \\bmod n \\] one can compute \\[ (a \\bmod n)^b \\bmod n \\] but one should not perform a modular reduction on the exponent. 2 One should, however, never simply attempt to compute the exponentiation \\(a^b\\) before performing a modular reduction as the number \\(a^b\\) would likely contain more digits then there are particles in the universe. Instead, one should use a special-purpose modular exponentiation method such as repeated squaring which prevents intermediate values from growing excessively large. Some languages include a native modular exponentiation primitive, but when this is not available a specialized modular exponentiation tool can be imported or written from scratch.","title":"Modular Exponentiation"},{"location":"spec/0.95.0/9_Verifier_construction/#hash-computation","text":"Hashes are computed using the SHA-256 hash function in NIST (2015) Secure Hash Standard (SHS) which is published in FIPS 180-4 and can be found in https://csrc.nist.gov/publications/detail/fips/180/4/final . For the purposes of SHA-256 hash computations, all inputs \u2013 whether textural or numeric \u2013 are represented as utf-8 encoded strings. Numbers are represented as strings in base ten. The hash function expects a single-dimensional array of input elements that are hashed iteratively, rather than concatenated together. Each element in the hash is separated by the pipe character (\u201c|\u201d). When dealing with multi-dimensional arrays, the elements are hashed recursively in the order in which they are input into the hash function. For instance, calling \\[ H(1,2,[3,4,5],6) \\] is a function call with 4 parameters, where the 3rd parameter is itself an array. The hash function will process arguments 1 and 2, when it gets to argument 3 it will traverse the array (and hash the values 3, 4 ,5) before hashing the final fourth argument (whose value is 6). When hashing an array element that is empty, the array is instead replaced with the word \u201cnull\u201d as a placeholder.","title":"Hash Computation"},{"location":"spec/0.95.0/9_Verifier_construction/#parameter-validation","text":"Important An ElectionGuard version 1 election verifier may assume that the baseline parameters match the parameters provided above. However, it is recommended that the below parameters be checked against the parameters of each election to accommodate the possibility of different parameters in future versions of ElectionGuard . 3 Variable Meaning Folder File Level \\(p\\) 4096-bit modulus root constants.json large_prime \\(q\\) 256-bit prime order of subgroup \\(Z_p^*\\) of encryptions root constants.json small_prime \\(r\\) co-factor of \\(q\\) root constants.json cofactor \\(g\\) generator of order \\(q\\) multiplicative subgroup of \\(Z_p^*\\) root contstants.json generator \\(n\\) number of guardians root context.json number_of_guardians \\(k\\) minimum number of guardians required to decrypt tallies and produce verification data root context.json quorum \\(Q\\) base hash value formed by \\(p\\) , \\(q\\) , \\(g\\) , \\(n\\) , \\(k\\) , date, and jurisdictional information root context.json crypto_base_hash","title":"Parameter Validation"},{"location":"spec/0.95.0/9_Verifier_construction/#guardian-public-key-validation","text":"Important An election verifier must confirm the following for each guardian \\(T_i\\) and for each \\(j \\in Z_k\\) : (A) The challenge \\(c_{i,j}\\) is correctly computed as \\[ c_{i,j}=H(Q,K_{i,j},h_{i,j} ) \\bmod q \\] (B) The equation \\[ g^{u_{i,j} } \\bmod p=h_{i,j} K_{i,j}^{c_{i,j} } \\bmod p \\] is satisfied. Variable Meaning Folder File Level \\(K_{i,j}\\) public form of each random coefficient \\(a_{i,j}\\) coefficients every file in this folder large_prime \\(h_(i,j)\\) coefficient commitments coefficients every file in this folder coefficient_proofs \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) commitment \\(c_i\\) challenge value coefficients every file in this folder coefficient_proofs \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) challenge \\(u_{i,j}\\) response coefficients every file in this folder coefficient_proofs \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) response","title":"Guardian Public Key Validation"},{"location":"spec/0.95.0/9_Verifier_construction/#election-public-key-validation","text":"Important An election verifier must verify the correct computation of the joint election public key and extended base hash. (A) Joint election public key \\[ K=\\prod_{i=1}^n K_i \\bmod p \\] (B) Extended base hash \\[ \\bar{Q} = H(Q,K_1,0,K_1,1,K_1,2,\\ldots,K_{1,k-1},K_2,0,K_2,1,K_2,2,\\ldots,K_{2,k-1},\\ldots,K_{n,0},K_{n,1},K_{n,2},\\ldots,K_{n,k-1}) \\] Variable Meaning Folder File Level \\(\\bar{Q}\\) extended base hash Root context.json crypto_extended_base_hash \\(K\\) joint election public key Root context.json elgamal_public_key","title":"Election Public Key Validation"},{"location":"spec/0.95.0/9_Verifier_construction/#correctness-of-selection-encryptions","text":"Important An election verifier must confirm the following for each possible selection on a ballot: The given values \\(\\alpha\\) , \\(\\beta\\) , \\(a_0\\) , \\(b_0\\) , \\(a_1\\) , and \\(b_1\\) are all in the set \\(Z_p^r\\) . (A value \\(x\\) is in \\(Z_p^r\\) if and only if \\(x\\) is an integer such that \\(0 \\le x \\lt p\\) and \\(x^q \\bmod p=1\\) is satisfied.) (J) The challenge \\(c\\) is correctly computed as \\[ c=H(\\bar{Q},(\\alpha,\\beta),(a_0,b_0 ),(a_1,b_1 )) \\] (K) The given values \\(c_0\\) , \\(c_1\\) , \\(v_0\\) , and \\(v_1\\) are each in the set \\(Z_q\\) . (A value \\(x\\) is in \\(Z_q\\) if and only if \\(x\\) is an integer such that 0 \\le x \\lt q.) (L) The equation \\[ c=(c_0+c_1 ) \\bmod q \\] is satisfied. (M) The equation \\[ g^{v_0} \\bmod p= a_0 \\alpha^{c_0} \\bmod p \\] is satisfied. (N) The equation \\[ g^{v_1} \\bmod p=a_1 \\alpha^{c_1} \\bmod p \\] is satisfied. (O) The equation \\[ K^{v_0} \\bmod p=b_0 \\beta^{c_0} \\bmod p \\] is satisfied. (P) The equation \\[ g^{c_1} K^{v_1} \\bmod p=b_1 \\beta^{c_1} \\bmod p \\] is satisfied. Variable Meaning Folder File Level \\((\\alpha,\\beta)\\) encryption of vote encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ciphertext \\(\\rightarrow\\) pad, data (a_0,b_0) commitment to vote being an encryption of zero encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_zero_pad, proof_zero_data \\((a_1,b_1)\\) commitment to vote being an encryption of one encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_one_pad, proof_one_data \\(c\\) challenge encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_challenge \\(c_0\\) derived challenge to encryption of zero encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_zero_challenge \\(c_1\\) derived challenge to encryption of one encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_one_challenge \\(v_0\\) response to zero challenge encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_zero_response \\(v_1\\) response to one challenge encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) proof_one_response","title":"Correctness of Selection Encryptions"},{"location":"spec/0.95.0/9_Verifier_construction/#adherence-to-vote-limits","text":"Important An election verifier must confirm the following for each contest on the ballot: (H) The number of placeholder positions matches the contest\u2019s selection limit \\(L\\) . (I) The contest total \\((A,B)\\) satisfies \\[ A=\\prod_i \\alpha_i \\bmod p \\] and \\[ B=\\prod_i \\beta_i \\bmod p \\] where the \\((\\alpha_i,\\beta_i )\\) represent all possible selections (including placeholder selections) for the contest. (J) The given value \\(V\\) is in \\(Z_q\\) . (K) The given values a and b are each in \\(Z_p^r\\) . (L) The challenge value \\(C\\) is correctly computed as \\[ C=H(\\bar{Q},(A,B),(a,b)) \\] (M) The equation \\[ g^V \\bmod p=(aA^C ) \\bmod p \\] is satisfied. (N) The equation \\[ ((g^{LC} K)^V ) \\bmod p=(bB^C ) \\bmod p \\] is satisfied. Variable Meaning Folder File Level \\((\\alpha_i,\\beta_i)\\) encryption of \\(i^th\\) vote in contest encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ciphertext \\(\\rightarrow\\) pad, data \\((A,B)\\) encryption of total votes in contest encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) total \\(\\rightarrow\\) pad, data \\((a,b)\\) commitment to vote being an encryption of one encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) total \\(\\rightarrow\\) proof \\(\\rightarrow\\) pad, data \\(C\\) selection limit challenge encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) challenge \\(L\\) contest selection limit root description.json contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) votes_allowed \\(V\\) response to selection limit challenge encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) response","title":"Adherence to Vote Limits"},{"location":"spec/0.95.0/9_Verifier_construction/#validation-of-ballot-chaining","text":"Important An election verifier must confirm that each of the values in the running hash is correctly computed. Specifically, an election verifier must confirm each of the following. (D) The equation \\(H_0=H(\\bar{Q})\\) is satisfied. (E) For each ballot \\[ B_i, H_i=H(H_{i-1},D,T,B_i) \\] is satisfied. (F) The closing hash \\[ \\bar{H} =H(H_l,\\text{\u201cCLOSE\"}) \\] is correctly computed from the final tracking code \\(H_l\\) . Variable Meaning Folder File Level \\(H_i\\) running hash of ballots produced encrypted_ballots every file in this folder tracking_hash (also previous_tracking_hash)","title":"Validation of Ballot Chaining"},{"location":"spec/0.95.0/9_Verifier_construction/#correctness-of-ballot-aggregation","text":"Important An election verifier must confirm for each (non-placeholder) option in each contest in the ballot coding file that the aggregate encryption \\((A,B)\\) satisfies \\[ A=\\prod_j\\alpha_j \\] and \\[ \\beta=\\prod_j \\beta_j \\] where the \\((\\alpha_j,\\beta_j )\\) are the corresponding encryptions on all cast ballots in the election record. Variable Meaning Folder File Level \\((\\alpha_j,\\beta_j)\\) encryption of vote encrypted_ballots every file in this folder contests \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ballot_selections \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) ciphertext \\(\\rightarrow\\) pad, data \\((A,B)\\) encrypted aggregate total of votes in contest root tally.json [prefix] \\(\\rightarrow\\) message \\(\\rightarrow\\) pad, data","title":"Correctness of Ballot Aggregation"},{"location":"spec/0.95.0/9_Verifier_construction/#correctness-of-partial-decryptions","text":"Important An election verifier must then confirm for each (non-placeholder) option in each contest in the ballot coding file the following for each decrypting trustee \\(T_i\\) . The given value \\(v_i\\) is in the set \\(Z_q\\) . The given values \\(a_i\\) and \\(b_i\\) are both in the set \\(Z_q^r\\) . The challenge value \\(c_i\\) satisfies \\[ c_i=H(\\bar{Q},(A,B),(a_i,b_i ),M_i ) \\] The equation \\[ g^{v_i} \\bmod p=(a_i K_i^{c_i} ) \\bmod p \\] is satisfied. The equation \\(A^{v_i} \\bmod p=(b_i M_i^{c_i} ) \\bmod p\\) is satisfied.","title":"Correctness of Partial Decryptions"},{"location":"spec/0.95.0/9_Verifier_construction/#correctness-of-partial-decryptions_1","text":"Important An election verifier must then confirm for each (non-placeholder) option in each contest in the ballot coding file the following for each decrypting trustee \\(T_i\\) . (F) The given value \\(v_i\\) is in the set of \\(Z_q\\) (G) The given values \\(a_i\\) and \\(b_i\\) are both in the set \\(Z_q^r\\) . (H) The challenge value \\(c_i\\) satisfies \\[ c_i=H(Q \u0305,(A,B),(a_i,b_i ),M_i ) \\] (I) The equation \\[ g^{v_i} \\bmod p=(a_i K_i^{c_i} ) \\bmod p \\] is satisfied. (J) The equation \\[ A^{v_i} \\bmod p=(b_i M_i^{c_i} ) \\bmod p \\] is satisfied. Variable Meaning Folder File Level \\((A,B)\\) encrypted aggregate total of votes in contest root tally.json [prefix] \\(\\rightarrow\\) message \\(\\rightarrow\\) pad, data \\(M_i\\) partial decryption of \\((A,B)\\) by guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) share \\((a_i,b_i)\\) commitment by guardian \\(T_i\\) to partial decryption of \\((A,B)\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) pad, data \\(c_i\\) challenge to partial decryption of guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) challenge \\(v_i\\) response to challenge of guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) proof \\(\\rightarrow\\) response","title":"Correctness of Partial Decryptions"},{"location":"spec/0.95.0/9_Verifier_construction/#correctness-of-substitute-data-for-missing-guardians","text":"Note This is only necessary if some guardians are missing during tallying Important An election verifier must confirm for each (non-placeholder) option in each contest in the ballot coding file the following for each missing trustee \\(T_i\\) and for each surrogate trustee \\(T_\\ell\\) . (A) The given value \\(v_{i,l}\\) is in the set \\(Z_q\\) . (B) The given values \\(a_{i,l}\\) and \\(b_{i,l}\\) are both in the set \\(Z_q^r\\) . (C) The challenge value \\(c_{i,l}\\) satisfies \\[ c_(i,l)=H(Q \u0305,(A,B),(a_(i,l),b_(i,l) ),M_(i,l) ) \\] (D) The equation \\[ g^{v_{i,l}} \\bmod p=\\left(a_{i,l}\\cdot \\left(\\prod_{j=0}^{k-1} K_{i,j}^{l^j} \\right)^{c_{i,l} } \\right) \\bmod p \\] is satisfied. (E) The equation \\[ A^{v_{i,\\ell}} \\bmod p= \\left( b_{i,\\ell} M_{i,l}^{c_{i,l}} \\right) \\bmod p \\] is satisfied. Variable Meaning Folder File Level \\((A,B)\\) encrypted aggregate total of votes in contest root tally.json [prefix] \\(\\rightarrow\\) message \\(\\rightarrow\\) pad, data \\(M_(i,\\ell)\\) share of guardian \\(T_\\ell\\) of missing partial decryption of \\((A,B)\\) by guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) substitute_proof \\(\\rightarrow\\) [item] \\(\\rightarrow\\) share \\((a_{i,l},b_{i,l})\\) commitment by guardian \\(T_\\ell\\) to share of partial decryption for missing guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) substitute_proof \\(\\rightarrow\\) [item] \\(\\rightarrow\\) pad, data \\(c_{i,\\ell}\\) challenge to guardian \\(T_\\ell\\) share of missing partial decryption of guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) substitute_proof \\(\\rightarrow\\) [item] \\(\\rightarrow\\) challenge \\(v_{i,l}\\) response to challenge of guardian \\(T_\\ell\\) share of partial decryption of guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) substitute_proof \\(\\rightarrow\\) [item] \\(\\rightarrow\\) response","title":"Correctness of Substitute Data for Missing Guardians"},{"location":"spec/0.95.0/9_Verifier_construction/#correctness-of-construction-of-replacement-partial-decryptions","text":"Note This is only necessary if some guardians are missing during tallying Important An election verifier should confirm that for each trustee \\(T_\\ell\\) serving to help compute a missing share of a tally, that its Lagrange coefficient \\(w_\\ell\\) is correctly computed by confirming the equation \\[ \\left(\\prod_{j\\in(U-{\\ell})}j\\right) \\bmod q=\\left(w_l\u22c5\\left(\\prod_{j\\in (U-{l})} (j-\\ell) \\right)\\right) \\bmod q \\] An election verifier should then confirm the correct missing tally share for each (non-placeholder) option in each contest in the ballot coding file for each missing trustee \\(T_i\\) as \\[ M_i=\\prod_{\\ell \\in U}\\left(M_{i,\\ell}\\right)^{w_\\ell} \\bmod p \\] Variable Meaning Folder File Level \\(w_\\ell\\) coefficient for use with shares of guardian \\(T_\\ell\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [item] \\(\\rightarrow\\) coefficient \\(M_{i,\\ell}\\) share of guardian \\(T_\\ell\\) of missing partial decryption of \\((A,B)\\) by guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) substitute_proof \\(\\rightarrow\\) [item] \\(\\rightarrow\\) share \\(M_i\\) partial decryption of \\((A,B)\\) by guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) share","title":"Correctness of Construction of Replacement Partial Decryptions"},{"location":"spec/0.95.0/9_Verifier_construction/#validation-of-correct-decryption-of-tallies","text":"Important An election verifier should confirm the following equations for each (non-placeholder) option in each contest in the ballot coding file. (C) \\[ B=\\left(M \\cdot \\left(\\prod_{i=1}^n M_i \\right)\\right) \\bmod p \\] (D) \\[ M=g^t \\bmod p \\] An election verifier should also confirm that the text labels listed in the election record match the corresponding text labels in the ballot coding file. Variable Meaning Folder File Level \\(M_i\\) partial decryption of \\((A,B)\\) by guardian \\(T_i\\) root tally.json [prefix] \\(\\rightarrow\\) shares \\(\\rightarrow\\) [Item] \\(\\rightarrow\\) share (M) full decryption of \\((A,B)\\) root tally.json [prefix] \\(\\rightarrow\\) value \\(t\\) tally value root tally.json [prefix] \\(\\rightarrow\\) tally","title":"Validation of Correct Decryption of Tallies"},{"location":"spec/0.95.0/9_Verifier_construction/#validation-of-correct-decryption-of-spoiled-ballots","text":"Important An election verifier should confirm the correct decryption of each spoiled ballot using the same process that was used to confirm the election tallies. An election verifier should also confirm that for each decrypted spoiled ballot, the selections listed in text match the corresponding text in the ballot coding file. Validation of Correct Decryption of Spoiled Ballots is a repeat of verification steps 8 through 11 for each spoiled ballot instead of for the aggregate ballot that contains encrypted tallies Special thanks to Rainbow Huang (@rainbowhuanguw) for her help in producing this mapping. \u21a9 In general, if \\(n\\) is prime, one can compute \\(a^b \\bmod n\\) as \\((a \\bmod n)^{(b \\bmod (n-1)} ) \\bmod n\\) . But within this application, the efficiency benefits of performing a modular reduction on an exponent are limited, and the risk of confusion or error from doing so likely exceeds the benefit. In the particular instance of this specification, if \\(a \\in Z_p^r\\) , then one can compute \\(a^b \\bmod p\\) as \\(a^{(b mod q)} \\bmod p\\) . This has greater efficiency benefits, but the risk of confusion or error still likely exceed the efficiency benefit. \u21a9 If alternative parameters are allowed, election verifiers must confirm that \\(p\\) , \\(q\\) , \\(r\\) , \\(g\\) , and $\\bar{g} are such that both \\(p\\) and \\(q\\) are prime (this may be done probabilistically using the Miller-Rabin algorithm), that \\(p-1=qr\\) is satisfied, that \\(q\\) is not a divisor of \\(r\\) , and \\(1 \\lt g \\lt p\\) , that \\(g^q \\bmod p=1\\) , that \\(g \\bar{g} \\bmod p=1\\) , and that generation of the parameters is consistent with the cited standard. \u21a9","title":"Validation of Correct Decryption of Spoiled Ballots"}]}